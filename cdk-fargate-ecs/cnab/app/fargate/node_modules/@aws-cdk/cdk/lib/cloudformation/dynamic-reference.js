"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const construct_1 = require("../core/construct");
const tokens_1 = require("../core/tokens");
/**
 * References a dynamically retrieved value
 *
 * This is a Construct so that subclasses will (eventually) be able to attach
 * metadata to themselves without having to change call signatures.
 *
 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html
 */
class DynamicReference extends construct_1.Construct {
    constructor(parent, id, props) {
        super(parent, id);
        this._value = this.makeResolveValue(props.service, props.referenceKey);
    }
    /**
     * The value of this dynamic reference
     */
    get value() {
        return this._value;
    }
    /**
     * Make a dynamic reference Token value
     *
     * This is a value (similar to CDK Tokens) that will be substituted by
     * CloudFormation before executing the changeset.
     */
    makeResolveValue(service, referenceKey) {
        const resolveString = '{{resolve:' + service + ':' + referenceKey + '}}';
        // We don't strictly need to Tokenize a string here, but we do it anyway to be perfectly
        // clear that DynamicReference.value is unparseable in CDK apps.
        return new tokens_1.Token(resolveString).toString();
    }
}
exports.DynamicReference = DynamicReference;
/**
 * The service to retrieve the dynamic reference from
 */
var DynamicReferenceService;
(function (DynamicReferenceService) {
    /**
     * Plaintext value stored in AWS Systems Manager Parameter Store
     */
    DynamicReferenceService["Ssm"] = "ssm";
    /**
     * Secure string stored in AWS Systems Manager Parameter Store
     */
    DynamicReferenceService["SsmSecure"] = "ssm-secure";
    /**
     * Secret stored in AWS Secrets Manager
     */
    DynamicReferenceService["SecretsManager"] = "secretsmanager";
})(DynamicReferenceService = exports.DynamicReferenceService || (exports.DynamicReferenceService = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1yZWZlcmVuY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeW5hbWljLXJlZmVyZW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUE4QztBQUM5QywyQ0FBdUM7QUFpQnZDOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLGdCQUFpQixTQUFRLHFCQUFTO0lBRzdDLFlBQVksTUFBaUIsRUFBRSxFQUFVLEVBQUUsS0FBNEI7UUFDckUsS0FBSyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLEtBQUs7UUFDZCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sZ0JBQWdCLENBQUMsT0FBZ0MsRUFBRSxZQUFvQjtRQUMvRSxNQUFNLGFBQWEsR0FBRyxZQUFZLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBRXpFLHdGQUF3RjtRQUN4RixnRUFBZ0U7UUFDaEUsT0FBTyxJQUFJLGNBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QyxDQUFDO0NBQ0Y7QUE3QkQsNENBNkJDO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLHVCQWVYO0FBZkQsV0FBWSx1QkFBdUI7SUFDakM7O09BRUc7SUFDSCxzQ0FBVyxDQUFBO0lBRVg7O09BRUc7SUFDSCxtREFBd0IsQ0FBQTtJQUV4Qjs7T0FFRztJQUNILDREQUFpQyxDQUFBO0FBQ25DLENBQUMsRUFmVyx1QkFBdUIsR0FBdkIsK0JBQXVCLEtBQXZCLCtCQUF1QixRQWVsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCIuLi9jb3JlL2NvbnN0cnVjdFwiO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi4vY29yZS90b2tlbnNcIjtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBhIER5bmFtaWMgUmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRHluYW1pY1JlZmVyZW5jZVByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIHRvIHJldHJpZXZlIHRoZSBkeW5hbWljIHJlZmVyZW5jZSBmcm9tXG4gICAqL1xuICBzZXJ2aWNlOiBEeW5hbWljUmVmZXJlbmNlU2VydmljZTtcblxuICAvKipcbiAgICogVGhlIHJlZmVyZW5jZSBrZXkgb2YgdGhlIGR5bmFtaWMgcmVmZXJlbmNlXG4gICAqL1xuICByZWZlcmVuY2VLZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGEgZHluYW1pY2FsbHkgcmV0cmlldmVkIHZhbHVlXG4gKlxuICogVGhpcyBpcyBhIENvbnN0cnVjdCBzbyB0aGF0IHN1YmNsYXNzZXMgd2lsbCAoZXZlbnR1YWxseSkgYmUgYWJsZSB0byBhdHRhY2hcbiAqIG1ldGFkYXRhIHRvIHRoZW1zZWx2ZXMgd2l0aG91dCBoYXZpbmcgdG8gY2hhbmdlIGNhbGwgc2lnbmF0dXJlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2R5bmFtaWMtcmVmZXJlbmNlcy5odG1sXG4gKi9cbmV4cG9ydCBjbGFzcyBEeW5hbWljUmVmZXJlbmNlIGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfdmFsdWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihwYXJlbnQ6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IER5bmFtaWNSZWZlcmVuY2VQcm9wcykge1xuICAgIHN1cGVyKHBhcmVudCwgaWQpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLm1ha2VSZXNvbHZlVmFsdWUocHJvcHMuc2VydmljZSwgcHJvcHMucmVmZXJlbmNlS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBkeW5hbWljIHJlZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgZHluYW1pYyByZWZlcmVuY2UgVG9rZW4gdmFsdWVcbiAgICpcbiAgICogVGhpcyBpcyBhIHZhbHVlIChzaW1pbGFyIHRvIENESyBUb2tlbnMpIHRoYXQgd2lsbCBiZSBzdWJzdGl0dXRlZCBieVxuICAgKiBDbG91ZEZvcm1hdGlvbiBiZWZvcmUgZXhlY3V0aW5nIHRoZSBjaGFuZ2VzZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgbWFrZVJlc29sdmVWYWx1ZShzZXJ2aWNlOiBEeW5hbWljUmVmZXJlbmNlU2VydmljZSwgcmVmZXJlbmNlS2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNvbHZlU3RyaW5nID0gJ3t7cmVzb2x2ZTonICsgc2VydmljZSArICc6JyArIHJlZmVyZW5jZUtleSArICd9fSc7XG5cbiAgICAvLyBXZSBkb24ndCBzdHJpY3RseSBuZWVkIHRvIFRva2VuaXplIGEgc3RyaW5nIGhlcmUsIGJ1dCB3ZSBkbyBpdCBhbnl3YXkgdG8gYmUgcGVyZmVjdGx5XG4gICAgLy8gY2xlYXIgdGhhdCBEeW5hbWljUmVmZXJlbmNlLnZhbHVlIGlzIHVucGFyc2VhYmxlIGluIENESyBhcHBzLlxuICAgIHJldHVybiBuZXcgVG9rZW4ocmVzb2x2ZVN0cmluZykudG9TdHJpbmcoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBzZXJ2aWNlIHRvIHJldHJpZXZlIHRoZSBkeW5hbWljIHJlZmVyZW5jZSBmcm9tXG4gKi9cbmV4cG9ydCBlbnVtIER5bmFtaWNSZWZlcmVuY2VTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIFBsYWludGV4dCB2YWx1ZSBzdG9yZWQgaW4gQVdTIFN5c3RlbXMgTWFuYWdlciBQYXJhbWV0ZXIgU3RvcmVcbiAgICovXG4gIFNzbSA9ICdzc20nLFxuXG4gIC8qKlxuICAgKiBTZWN1cmUgc3RyaW5nIHN0b3JlZCBpbiBBV1MgU3lzdGVtcyBNYW5hZ2VyIFBhcmFtZXRlciBTdG9yZVxuICAgKi9cbiAgU3NtU2VjdXJlID0gJ3NzbS1zZWN1cmUnLFxuXG4gIC8qKlxuICAgKiBTZWNyZXQgc3RvcmVkIGluIEFXUyBTZWNyZXRzIE1hbmFnZXJcbiAgICovXG4gIFNlY3JldHNNYW5hZ2VyID0gJ3NlY3JldHNtYW5hZ2VyJyxcbn1cbiJdfQ==