"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const construct_1 = require("./construct");
/**
 * If objects has a function property by this name, they will be considered tokens, and this
 * function will be called to resolve the value for this object.
 */
exports.RESOLVE_METHOD = 'resolve';
/**
 * Represents a special or lazily-evaluated value.
 *
 * Can be used to delay evaluation of a certain value in case, for example,
 * that it requires some context or late-bound data. Can also be used to
 * mark values that need special processing at document rendering time.
 *
 * Tokens can be embedded into strings while retaining their original
 * semantics.
 */
class Token {
    /**
     * Creates a token that resolves to `value`.
     *
     * If value is a function, the function is evaluated upon resolution and
     * the value it returns will be used as the token's value.
     *
     * displayName is used to represent the Token when it's embedded into a string; it
     * will look something like this:
     *
     *    "embedded in a larger string is ${Token[DISPLAY_NAME.123]}"
     *
     * This value is used as a hint to humans what the meaning of the Token is,
     * and does not have any effect on the evaluation.
     *
     * Must contain only alphanumeric and simple separator characters (_.:-).
     *
     * @param valueOrFunction What this token will evaluate to, literal or function.
     * @param displayName A human-readable display hint for this Token
     */
    constructor(valueOrFunction, displayName) {
        this.valueOrFunction = valueOrFunction;
        this.displayName = displayName;
    }
    /**
     * @returns The resolved value for this token.
     */
    resolve() {
        let value = this.valueOrFunction;
        if (typeof (value) === 'function') {
            value = value();
        }
        return value;
    }
    /**
     * Return a reversible string representation of this token
     *
     * If the Token is initialized with a literal, the stringified value of the
     * literal is returned. Otherwise, a special quoted string representation
     * of the Token is returned that can be embedded into other strings.
     *
     * Strings with quoted Tokens in them can be restored back into
     * complex values with the Tokens restored by calling `resolve()`
     * on the string.
     */
    toString() {
        const valueType = typeof this.valueOrFunction;
        // Optimization: if we can immediately resolve this, don't bother
        // registering a Token.
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            return this.valueOrFunction.toString();
        }
        if (this.tokenStringification === undefined) {
            this.tokenStringification = TOKEN_MAP.registerString(this, this.displayName);
        }
        return this.tokenStringification;
    }
    /**
     * Turn this Token into JSON
     *
     * This gets called by JSON.stringify(). We want to prohibit this, because
     * it's not possible to do this properly, so we just throw an error here.
     */
    toJSON() {
        // tslint:disable-next-line:max-line-length
        throw new Error('JSON.stringify() cannot be applied to structure with a Token in it. Use a document-specific stringification method instead.');
    }
    /**
     * Return a string list representation of this token
     *
     * Call this if the Token intrinsically evaluates to a list of strings.
     * If so, you can represent the Token in a similar way in the type
     * system.
     *
     * Note that even though the Token is represented as a list of strings, you
     * still cannot do any operations on it such as concatenation, indexing,
     * or taking its length. The only useful operations you can do to these lists
     * is constructing a `FnJoin` or a `FnSelect` on it.
     */
    toList() {
        const valueType = typeof this.valueOrFunction;
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            throw new Error('Got a literal Token value; cannot be encoded as a list.');
        }
        if (this.tokenListification === undefined) {
            this.tokenListification = TOKEN_MAP.registerList(this, this.displayName);
        }
        return this.tokenListification;
    }
    /**
     * Return a concated version of this Token in a string context
     *
     * The default implementation of this combines strings, but specialized
     * implements of Token can return a more appropriate value.
     */
    concat(left, right) {
        const parts = [left, resolve(this), right].filter(x => x !== undefined);
        return new Token(parts.map(x => `${x}`).join(''));
    }
}
exports.Token = Token;
/**
 * Returns true if obj is a token (i.e. has the resolve() method or is a string
 * that includes token markers), or it's a listifictaion of a Token string.
 *
 * @param obj The object to test.
 */
function unresolved(obj) {
    if (typeof (obj) === 'string') {
        return TOKEN_MAP.createStringTokenString(obj).test();
    }
    else if (Array.isArray(obj) && obj.length === 1) {
        return isListToken(obj[0]);
    }
    else {
        return typeof (obj[exports.RESOLVE_METHOD]) === 'function';
    }
}
exports.unresolved = unresolved;
/**
 * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.
 * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.
 *
 * @param obj The object to resolve.
 * @param prefix Prefix key path components for diagnostics.
 */
function resolve(obj, prefix) {
    const path = prefix || [];
    const pathName = '/' + path.join('/');
    // protect against cyclic references by limiting depth.
    if (path.length > 200) {
        throw new Error('Unable to resolve object tree with circular reference. Path: ' + pathName);
    }
    //
    // undefined
    //
    if (typeof (obj) === 'undefined') {
        return undefined;
    }
    //
    // null
    //
    if (obj === null) {
        return null;
    }
    //
    // functions - not supported (only tokens are supported)
    //
    if (typeof (obj) === 'function') {
        throw new Error(`Trying to resolve a non-data object. Only token are supported for lazy evaluation. Path: ${pathName}. Object: ${obj}`);
    }
    //
    // string - potentially replace all stringified Tokens
    //
    if (typeof (obj) === 'string') {
        return TOKEN_MAP.resolveStringTokens(obj);
    }
    //
    // primitives - as-is
    //
    if (typeof (obj) !== 'object' || obj instanceof Date) {
        return obj;
    }
    //
    // arrays - resolve all values, remove undefined and remove empty arrays
    //
    if (Array.isArray(obj)) {
        if (containsListToken(obj)) {
            return TOKEN_MAP.resolveListTokens(obj);
        }
        const arr = obj
            .map((x, i) => resolve(x, path.concat(i.toString())))
            .filter(x => typeof (x) !== 'undefined');
        return arr;
    }
    //
    // tokens - invoke 'resolve' and continue to resolve recursively
    //
    if (unresolved(obj)) {
        const value = obj[exports.RESOLVE_METHOD]();
        return resolve(value, path);
    }
    //
    // objects - deep-resolve all values
    //
    // Must not be a Construct at this point, otherwise you probably made a type
    // mistake somewhere and resolve will get into an infinite loop recursing into
    // child.parent <---> parent.children
    if (obj instanceof construct_1.Construct) {
        throw new Error('Trying to resolve() a Construct at ' + pathName);
    }
    const result = {};
    for (const key of Object.keys(obj)) {
        const resolvedKey = resolve(key);
        if (typeof (resolvedKey) !== 'string') {
            throw new Error(`The key "${key}" has been resolved to ${JSON.stringify(resolvedKey)} but must be resolvable to a string`);
        }
        const value = resolve(obj[key], path.concat(key));
        // skip undefined
        if (typeof (value) === 'undefined') {
            continue;
        }
        result[resolvedKey] = value;
    }
    return result;
}
exports.resolve = resolve;
function isListToken(x) {
    return typeof (x) === 'string' && TOKEN_MAP.createListTokenString(x).test();
}
function containsListToken(xs) {
    return xs.some(isListToken);
}
/**
 * Central place where we keep a mapping from Tokens to their String representation
 *
 * The string representation is used to embed token into strings,
 * and stored to be able to
 *
 * All instances of TokenStringMap share the same storage, so that this process
 * works even when different copies of the library are loaded.
 */
class TokenMap {
    constructor() {
        const glob = global;
        this.tokenMap = glob.__cdkTokenMap = glob.__cdkTokenMap || {};
    }
    /**
     * Generate a unique string for this Token, returning a key
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * The token can choose (part of) its own representation string with a
     * hint. This may be used to produce aesthetically pleasing and
     * recognizable token representations for humans.
     */
    registerString(token, representationHint) {
        const key = this.register(token, representationHint);
        return `${BEGIN_STRING_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`;
    }
    /**
     * Generate a unique string for this Token, returning a key
     */
    registerList(token, representationHint) {
        const key = this.register(token, representationHint);
        return [`${BEGIN_LIST_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`];
    }
    /**
     * Returns a `TokenString` for this string.
     */
    createStringTokenString(s) {
        return new TokenString(s, BEGIN_STRING_TOKEN_MARKER, `[${VALID_KEY_CHARS}]+`, END_TOKEN_MARKER);
    }
    /**
     * Returns a `TokenString` for this string.
     */
    createListTokenString(s) {
        return new TokenString(s, BEGIN_LIST_TOKEN_MARKER, `[${VALID_KEY_CHARS}]+`, END_TOKEN_MARKER);
    }
    /**
     * Replace any Token markers in this string with their resolved values
     */
    resolveStringTokens(s) {
        const str = this.createStringTokenString(s);
        const fragments = str.split(this.lookupToken.bind(this));
        return fragments.join();
    }
    resolveListTokens(xs) {
        // Must be a singleton list token, because concatenation is not allowed.
        if (xs.length !== 1) {
            throw new Error(`Cannot add elements to list token, got: ${xs}`);
        }
        const str = this.createListTokenString(xs[0]);
        const fragments = str.split(this.lookupToken.bind(this));
        if (fragments.length !== 1) {
            throw new Error(`Cannot concatenate strings in a tokenized string array, got: ${xs[0]}`);
        }
        return fragments.values()[0];
    }
    /**
     * Find a Token by key
     */
    lookupToken(key) {
        if (!(key in this.tokenMap)) {
            throw new Error(`Unrecognized token key: ${key}`);
        }
        return this.tokenMap[key];
    }
    register(token, representationHint) {
        const counter = Object.keys(this.tokenMap).length;
        const representation = representationHint || `TOKEN`;
        const key = `${representation}.${counter}`;
        if (new RegExp(`[^${VALID_KEY_CHARS}]`).exec(key)) {
            throw new Error(`Invalid characters in token representation: ${key}`);
        }
        this.tokenMap[key] = token;
        return key;
    }
}
const BEGIN_STRING_TOKEN_MARKER = '${Token[';
const BEGIN_LIST_TOKEN_MARKER = '#{Token[';
const END_TOKEN_MARKER = ']}';
const VALID_KEY_CHARS = 'a-zA-Z0-9:._-';
/**
 * Singleton instance of the token string map
 */
const TOKEN_MAP = new TokenMap();
/**
 * A string with markers in it that can be resolved to external values
 */
class TokenString {
    constructor(str, beginMarker, idPattern, endMarker) {
        this.str = str;
        this.beginMarker = beginMarker;
        this.idPattern = idPattern;
        this.endMarker = endMarker;
        this.pattern = `${regexQuote(this.beginMarker)}(${this.idPattern})${regexQuote(this.endMarker)}`;
    }
    /**
     * Split string on markers, substituting markers with Tokens
     */
    split(lookup) {
        const re = new RegExp(this.pattern, 'g');
        const ret = new TokenStringFragments();
        let rest = 0;
        let m = re.exec(this.str);
        while (m) {
            if (m.index > rest) {
                ret.addString(this.str.substring(rest, m.index));
            }
            ret.addToken(lookup(m[1]));
            rest = re.lastIndex;
            m = re.exec(this.str);
        }
        if (rest < this.str.length) {
            ret.addString(this.str.substring(rest));
        }
        return ret;
    }
    /**
     * Indicates if this string includes tokens.
     */
    test() {
        const re = new RegExp(this.pattern, 'g');
        return re.test(this.str);
    }
}
/**
 * Fragments of a string with markers
 */
class TokenStringFragments {
    constructor() {
        this.fragments = new Array();
    }
    get length() {
        return this.fragments.length;
    }
    values() {
        return this.fragments.map(f => f.type === 'token' ? resolve(f.token) : f.str);
    }
    addString(str) {
        this.fragments.push({ type: 'string', str });
    }
    addToken(token) {
        this.fragments.push({ type: 'token', token });
    }
    /**
     * Combine the resolved string fragments using the Tokens to join.
     *
     * Resolves the result.
     */
    join() {
        if (this.fragments.length === 0) {
            return '';
        }
        if (this.fragments.length === 1) {
            return resolveFragment(this.fragments[0]);
        }
        const first = this.fragments[0];
        let i;
        let token;
        if (first.type === 'token') {
            token = first.token;
            i = 1;
        }
        else {
            // We never have two strings in a row
            token = this.fragments[1].token.concat(first.str, undefined);
            i = 2;
        }
        while (i < this.fragments.length) {
            token = token.concat(undefined, resolveFragment(this.fragments[i]));
            i++;
        }
        return resolve(token);
    }
}
/**
 * Resolve the value from a single fragment
 */
function resolveFragment(fragment) {
    return fragment.type === 'string' ? fragment.str : resolve(fragment.token);
}
/**
 * Quote a string for use in a regex
 */
function regexQuote(s) {
    return s.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9rZW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkNBQXdDO0FBRXhDOzs7R0FHRztBQUNVLFFBQUEsY0FBYyxHQUFHLFNBQVMsQ0FBQztBQUV4Qzs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFhLEtBQUs7SUFJaEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNILFlBQTZCLGVBQXFCLEVBQW1CLFdBQW9CO1FBQTVELG9CQUFlLEdBQWYsZUFBZSxDQUFNO1FBQW1CLGdCQUFXLEdBQVgsV0FBVyxDQUFTO0lBQ3pGLENBQUM7SUFFRDs7T0FFRztJQUNJLE9BQU87UUFDWixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ2pDLElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUNoQyxLQUFLLEdBQUcsS0FBSyxFQUFFLENBQUM7U0FDakI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksUUFBUTtRQUNiLE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM5QyxpRUFBaUU7UUFDakUsdUJBQXVCO1FBQ3ZCLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDL0UsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssU0FBUyxFQUFFO1lBQzNDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDOUU7UUFDRCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxN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LE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ2hGLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDUDtRQUVELE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFO1lBQ2hDLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEUsQ0FBQyxFQUFFLENBQUM7U0FDTDtRQUVELE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsU0FBUyxlQUFlLENBQUMsUUFBa0I7SUFDekMsT0FBTyxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM3RSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNuRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcIi4vY29uc3RydWN0XCI7XG5cbi8qKlxuICogSWYgb2JqZWN0cyBoYXMgYSBmdW5jdGlvbiBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsIHRoZXkgd2lsbCBiZSBjb25zaWRlcmVkIHRva2VucywgYW5kIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHJlc29sdmUgdGhlIHZhbHVlIGZvciB0aGlzIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IFJFU09MVkVfTUVUSE9EID0gJ3Jlc29sdmUnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcGVjaWFsIG9yIGxhemlseS1ldmFsdWF0ZWQgdmFsdWUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gZGVsYXkgZXZhbHVhdGlvbiBvZiBhIGNlcnRhaW4gdmFsdWUgaW4gY2FzZSwgZm9yIGV4YW1wbGUsXG4gKiB0aGF0IGl0IHJlcXVpcmVzIHNvbWUgY29udGV4dCBvciBsYXRlLWJvdW5kIGRhdGEuIENhbiBhbHNvIGJlIHVzZWQgdG9cbiAqIG1hcmsgdmFsdWVzIHRoYXQgbmVlZCBzcGVjaWFsIHByb2Nlc3NpbmcgYXQgZG9jdW1lbnQgcmVuZGVyaW5nIHRpbWUuXG4gKlxuICogVG9rZW5zIGNhbiBiZSBlbWJlZGRlZCBpbnRvIHN0cmluZ3Mgd2hpbGUgcmV0YWluaW5nIHRoZWlyIG9yaWdpbmFsXG4gKiBzZW1hbnRpY3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbiB7XG4gIHByaXZhdGUgdG9rZW5TdHJpbmdpZmljYXRpb24/OiBzdHJpbmc7XG4gIHByaXZhdGUgdG9rZW5MaXN0aWZpY2F0aW9uPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0b2tlbiB0aGF0IHJlc29sdmVzIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgdXBvbiByZXNvbHV0aW9uIGFuZFxuICAgKiB0aGUgdmFsdWUgaXQgcmV0dXJucyB3aWxsIGJlIHVzZWQgYXMgdGhlIHRva2VuJ3MgdmFsdWUuXG4gICAqXG4gICAqIGRpc3BsYXlOYW1lIGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBUb2tlbiB3aGVuIGl0J3MgZW1iZWRkZWQgaW50byBhIHN0cmluZzsgaXRcbiAgICogd2lsbCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAqXG4gICAqICAgIFwiZW1iZWRkZWQgaW4gYSBsYXJnZXIgc3RyaW5nIGlzICR7VG9rZW5bRElTUExBWV9OQU1FLjEyM119XCJcbiAgICpcbiAgICogVGhpcyB2YWx1ZSBpcyB1c2VkIGFzIGEgaGludCB0byBodW1hbnMgd2hhdCB0aGUgbWVhbmluZyBvZiB0aGUgVG9rZW4gaXMsXG4gICAqIGFuZCBkb2VzIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGV2YWx1YXRpb24uXG4gICAqXG4gICAqIE11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBhbmQgc2ltcGxlIHNlcGFyYXRvciBjaGFyYWN0ZXJzIChfLjotKS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlT3JGdW5jdGlvbiBXaGF0IHRoaXMgdG9rZW4gd2lsbCBldmFsdWF0ZSB0bywgbGl0ZXJhbCBvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGRpc3BsYXlOYW1lIEEgaHVtYW4tcmVhZGFibGUgZGlzcGxheSBoaW50IGZvciB0aGlzIFRva2VuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHZhbHVlT3JGdW5jdGlvbj86IGFueSwgcHJpdmF0ZSByZWFkb25seSBkaXNwbGF5TmFtZT86IHN0cmluZykge1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhpcyB0b2tlbi5cbiAgICovXG4gIHB1YmxpYyByZXNvbHZlKCk6IGFueSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZU9yRnVuY3Rpb247XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcmV2ZXJzaWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0b2tlblxuICAgKlxuICAgKiBJZiB0aGUgVG9rZW4gaXMgaW5pdGlhbGl6ZWQgd2l0aCBhIGxpdGVyYWwsIHRoZSBzdHJpbmdpZmllZCB2YWx1ZSBvZiB0aGVcbiAgICogbGl0ZXJhbCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIHNwZWNpYWwgcXVvdGVkIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgVG9rZW4gaXMgcmV0dXJuZWQgdGhhdCBjYW4gYmUgZW1iZWRkZWQgaW50byBvdGhlciBzdHJpbmdzLlxuICAgKlxuICAgKiBTdHJpbmdzIHdpdGggcXVvdGVkIFRva2VucyBpbiB0aGVtIGNhbiBiZSByZXN0b3JlZCBiYWNrIGludG9cbiAgICogY29tcGxleCB2YWx1ZXMgd2l0aCB0aGUgVG9rZW5zIHJlc3RvcmVkIGJ5IGNhbGxpbmcgYHJlc29sdmUoKWBcbiAgICogb24gdGhlIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlT3JGdW5jdGlvbjtcbiAgICAvLyBPcHRpbWl6YXRpb246IGlmIHdlIGNhbiBpbW1lZGlhdGVseSByZXNvbHZlIHRoaXMsIGRvbid0IGJvdGhlclxuICAgIC8vIHJlZ2lzdGVyaW5nIGEgVG9rZW4uXG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycgfHwgdmFsdWVUeXBlID09PSAnbnVtYmVyJyB8fCB2YWx1ZVR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVPckZ1bmN0aW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW5TdHJpbmdpZmljYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2tlblN0cmluZ2lmaWNhdGlvbiA9IFRPS0VOX01BUC5yZWdpc3RlclN0cmluZyh0aGlzLCB0aGlzLmRpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9rZW5TdHJpbmdpZmljYXRpb247XG4gIH1cblxuICAvKipcbiAgICogVHVybiB0aGlzIFRva2VuIGludG8gSlNPTlxuICAgKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIGJ5IEpTT04uc3RyaW5naWZ5KCkuIFdlIHdhbnQgdG8gcHJvaGliaXQgdGhpcywgYmVjYXVzZVxuICAgKiBpdCdzIG5vdCBwb3NzaWJsZSB0byBkbyB0aGlzIHByb3Blcmx5LCBzbyB3ZSBqdXN0IHRocm93IGFuIGVycm9yIGhlcmUuXG4gICAqL1xuICBwdWJsaWMgdG9KU09OKCk6IGFueSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnkoKSBjYW5ub3QgYmUgYXBwbGllZCB0byBzdHJ1Y3R1cmUgd2l0aCBhIFRva2VuIGluIGl0LiBVc2UgYSBkb2N1bWVudC1zcGVjaWZpYyBzdHJpbmdpZmljYXRpb24gbWV0aG9kIGluc3RlYWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIGxpc3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0b2tlblxuICAgKlxuICAgKiBDYWxsIHRoaXMgaWYgdGhlIFRva2VuIGludHJpbnNpY2FsbHkgZXZhbHVhdGVzIHRvIGEgbGlzdCBvZiBzdHJpbmdzLlxuICAgKiBJZiBzbywgeW91IGNhbiByZXByZXNlbnQgdGhlIFRva2VuIGluIGEgc2ltaWxhciB3YXkgaW4gdGhlIHR5cGVcbiAgICogc3lzdGVtLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIFRva2VuIGlzIHJlcHJlc2VudGVkIGFzIGEgbGlzdCBvZiBzdHJpbmdzLCB5b3VcbiAgICogc3RpbGwgY2Fubm90IGRvIGFueSBvcGVyYXRpb25zIG9uIGl0IHN1Y2ggYXMgY29uY2F0ZW5hdGlvbiwgaW5kZXhpbmcsXG4gICAqIG9yIHRha2luZyBpdHMgbGVuZ3RoLiBUaGUgb25seSB1c2VmdWwgb3BlcmF0aW9ucyB5b3UgY2FuIGRvIHRvIHRoZXNlIGxpc3RzXG4gICAqIGlzIGNvbnN0cnVjdGluZyBhIGBGbkpvaW5gIG9yIGEgYEZuU2VsZWN0YCBvbiBpdC5cbiAgICovXG4gIHB1YmxpYyB0b0xpc3QoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlT3JGdW5jdGlvbjtcbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJyB8fCB2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8IHZhbHVlVHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvdCBhIGxpdGVyYWwgVG9rZW4gdmFsdWU7IGNhbm5vdCBiZSBlbmNvZGVkIGFzIGEgbGlzdC4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbkxpc3RpZmljYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2tlbkxpc3RpZmljYXRpb24gPSBUT0tFTl9NQVAucmVnaXN0ZXJMaXN0KHRoaXMsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbkxpc3RpZmljYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29uY2F0ZWQgdmVyc2lvbiBvZiB0aGlzIFRva2VuIGluIGEgc3RyaW5nIGNvbnRleHRcbiAgICpcbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBjb21iaW5lcyBzdHJpbmdzLCBidXQgc3BlY2lhbGl6ZWRcbiAgICogaW1wbGVtZW50cyBvZiBUb2tlbiBjYW4gcmV0dXJuIGEgbW9yZSBhcHByb3ByaWF0ZSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBjb25jYXQobGVmdDogYW55IHwgdW5kZWZpbmVkLCByaWdodDogYW55IHwgdW5kZWZpbmVkKTogVG9rZW4ge1xuICAgIGNvbnN0IHBhcnRzID0gW2xlZnQsIHJlc29sdmUodGhpcyksIHJpZ2h0XS5maWx0ZXIoeCA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICAgIHJldHVybiBuZXcgVG9rZW4ocGFydHMubWFwKHggPT4gYCR7eH1gKS5qb2luKCcnKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgdG9rZW4gKGkuZS4gaGFzIHRoZSByZXNvbHZlKCkgbWV0aG9kIG9yIGlzIGEgc3RyaW5nXG4gKiB0aGF0IGluY2x1ZGVzIHRva2VuIG1hcmtlcnMpLCBvciBpdCdzIGEgbGlzdGlmaWN0YWlvbiBvZiBhIFRva2VuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucmVzb2x2ZWQob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBUT0tFTl9NQVAuY3JlYXRlU3RyaW5nVG9rZW5TdHJpbmcob2JqKS50ZXN0KCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gaXNMaXN0VG9rZW4ob2JqWzBdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZW9mKG9ialtSRVNPTFZFX01FVEhPRF0pID09PSAnZnVuY3Rpb24nO1xuICB9XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW4gb2JqZWN0IGJ5IGV2YWx1YXRpbmcgYWxsIHRva2VucyBhbmQgcmVtb3ZpbmcgYW55IHVuZGVmaW5lZCBvciBlbXB0eSBvYmplY3RzIG9yIGFycmF5cy5cbiAqIFZhbHVlcyBjYW4gb25seSBiZSBwcmltaXRpdmVzLCBhcnJheXMgb3IgdG9rZW5zLiBPdGhlciBvYmplY3RzIChpLmUuIHdpdGggbWV0aG9kcykgd2lsbCBiZSByZWplY3RlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gcmVzb2x2ZS5cbiAqIEBwYXJhbSBwcmVmaXggUHJlZml4IGtleSBwYXRoIGNvbXBvbmVudHMgZm9yIGRpYWdub3N0aWNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShvYmo6IGFueSwgcHJlZml4Pzogc3RyaW5nW10pOiBhbnkge1xuICBjb25zdCBwYXRoID0gcHJlZml4IHx8IFsgXTtcbiAgY29uc3QgcGF0aE5hbWUgPSAnLycgKyBwYXRoLmpvaW4oJy8nKTtcblxuICAvLyBwcm90ZWN0IGFnYWluc3QgY3ljbGljIHJlZmVyZW5jZXMgYnkgbGltaXRpbmcgZGVwdGguXG4gIGlmIChwYXRoLmxlbmd0aCA+IDIwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlc29sdmUgb2JqZWN0IHRyZWUgd2l0aCBjaXJjdWxhciByZWZlcmVuY2UuIFBhdGg6ICcgKyBwYXRoTmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyB1bmRlZmluZWRcbiAgLy9cblxuICBpZiAodHlwZW9mKG9iaikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vXG4gIC8vIG51bGxcbiAgLy9cblxuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvL1xuICAvLyBmdW5jdGlvbnMgLSBub3Qgc3VwcG9ydGVkIChvbmx5IHRva2VucyBhcmUgc3VwcG9ydGVkKVxuICAvL1xuXG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHJlc29sdmUgYSBub24tZGF0YSBvYmplY3QuIE9ubHkgdG9rZW4gYXJlIHN1cHBvcnRlZCBmb3IgbGF6eSBldmFsdWF0aW9uLiBQYXRoOiAke3BhdGhOYW1lfS4gT2JqZWN0OiAke29ian1gKTtcbiAgfVxuXG4gIC8vXG4gIC8vIHN0cmluZyAtIHBvdGVudGlhbGx5IHJlcGxhY2UgYWxsIHN0cmluZ2lmaWVkIFRva2Vuc1xuICAvL1xuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFRPS0VOX01BUC5yZXNvbHZlU3RyaW5nVG9rZW5zKG9iaiBhcyBzdHJpbmcpO1xuICB9XG5cbiAgLy9cbiAgLy8gcHJpbWl0aXZlcyAtIGFzLWlzXG4gIC8vXG5cbiAgaWYgKHR5cGVvZihvYmopICE9PSAnb2JqZWN0JyB8fCBvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8vXG4gIC8vIGFycmF5cyAtIHJlc29sdmUgYWxsIHZhbHVlcywgcmVtb3ZlIHVuZGVmaW5lZCBhbmQgcmVtb3ZlIGVtcHR5IGFycmF5c1xuICAvL1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBpZiAoY29udGFpbnNMaXN0VG9rZW4ob2JqKSkge1xuICAgICAgcmV0dXJuIFRPS0VOX01BUC5yZXNvbHZlTGlzdFRva2VucyhvYmopO1xuICAgIH1cblxuICAgIGNvbnN0IGFyciA9IG9ialxuICAgICAgLm1hcCgoeCwgaSkgPT4gcmVzb2x2ZSh4LCBwYXRoLmNvbmNhdChpLnRvU3RyaW5nKCkpKSlcbiAgICAgIC5maWx0ZXIoeCA9PiB0eXBlb2YoeCkgIT09ICd1bmRlZmluZWQnKTtcblxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICAvL1xuICAvLyB0b2tlbnMgLSBpbnZva2UgJ3Jlc29sdmUnIGFuZCBjb250aW51ZSB0byByZXNvbHZlIHJlY3Vyc2l2ZWx5XG4gIC8vXG5cbiAgaWYgKHVucmVzb2x2ZWQob2JqKSkge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW1JFU09MVkVfTUVUSE9EXSgpO1xuICAgIHJldHVybiByZXNvbHZlKHZhbHVlLCBwYXRoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIG9iamVjdHMgLSBkZWVwLXJlc29sdmUgYWxsIHZhbHVlc1xuICAvL1xuXG4gIC8vIE11c3Qgbm90IGJlIGEgQ29uc3RydWN0IGF0IHRoaXMgcG9pbnQsIG90aGVyd2lzZSB5b3UgcHJvYmFibHkgbWFkZSBhIHR5cGVcbiAgLy8gbWlzdGFrZSBzb21ld2hlcmUgYW5kIHJlc29sdmUgd2lsbCBnZXQgaW50byBhbiBpbmZpbml0ZSBsb29wIHJlY3Vyc2luZyBpbnRvXG4gIC8vIGNoaWxkLnBhcmVudCA8LS0tPiBwYXJlbnQuY2hpbGRyZW5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnN0cnVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlc29sdmUoKSBhIENvbnN0cnVjdCBhdCAnICsgcGF0aE5hbWUpO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICBjb25zdCByZXNvbHZlZEtleSA9IHJlc29sdmUoa2V5KTtcbiAgICBpZiAodHlwZW9mKHJlc29sdmVkS2V5KSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGtleSBcIiR7a2V5fVwiIGhhcyBiZWVuIHJlc29sdmVkIHRvICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRLZXkpfSBidXQgbXVzdCBiZSByZXNvbHZhYmxlIHRvIGEgc3RyaW5nYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSByZXNvbHZlKG9ialtrZXldLCBwYXRoLmNvbmNhdChrZXkpKTtcblxuICAgIC8vIHNraXAgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXN1bHRbcmVzb2x2ZWRLZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0xpc3RUb2tlbih4OiBhbnkpIHtcbiAgICByZXR1cm4gdHlwZW9mKHgpID09PSAnc3RyaW5nJyAmJiBUT0tFTl9NQVAuY3JlYXRlTGlzdFRva2VuU3RyaW5nKHgpLnRlc3QoKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNMaXN0VG9rZW4oeHM6IGFueVtdKSB7XG4gIHJldHVybiB4cy5zb21lKGlzTGlzdFRva2VuKTtcbn1cblxuLyoqXG4gKiBDZW50cmFsIHBsYWNlIHdoZXJlIHdlIGtlZXAgYSBtYXBwaW5nIGZyb20gVG9rZW5zIHRvIHRoZWlyIFN0cmluZyByZXByZXNlbnRhdGlvblxuICpcbiAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgdXNlZCB0byBlbWJlZCB0b2tlbiBpbnRvIHN0cmluZ3MsXG4gKiBhbmQgc3RvcmVkIHRvIGJlIGFibGUgdG9cbiAqXG4gKiBBbGwgaW5zdGFuY2VzIG9mIFRva2VuU3RyaW5nTWFwIHNoYXJlIHRoZSBzYW1lIHN0b3JhZ2UsIHNvIHRoYXQgdGhpcyBwcm9jZXNzXG4gKiB3b3JrcyBldmVuIHdoZW4gZGlmZmVyZW50IGNvcGllcyBvZiB0aGUgbGlicmFyeSBhcmUgbG9hZGVkLlxuICovXG5jbGFzcyBUb2tlbk1hcCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgdG9rZW5NYXA6IHtba2V5OiBzdHJpbmddOiBUb2tlbn07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgZ2xvYiA9IGdsb2JhbCBhcyBhbnk7XG4gICAgdGhpcy50b2tlbk1hcCA9IGdsb2IuX19jZGtUb2tlbk1hcCA9IGdsb2IuX19jZGtUb2tlbk1hcCB8fCB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBzdHJpbmcgZm9yIHRoaXMgVG9rZW4sIHJldHVybmluZyBhIGtleVxuICAgKlxuICAgKiBFdmVyeSBjYWxsIGZvciB0aGUgc2FtZSBUb2tlbiB3aWxsIHByb2R1Y2UgYSBuZXcgdW5pcXVlIHN0cmluZywgbm9cbiAgICogYXR0ZW1wdCBpcyBtYWRlIHRvIGRlZHVwbGljYXRlLiBUb2tlbiBvYmplY3RzIHNob3VsZCBjYWNoZSB0aGVcbiAgICogdmFsdWUgdGhlbXNlbHZlcywgaWYgcmVxdWlyZWQuXG4gICAqXG4gICAqIFRoZSB0b2tlbiBjYW4gY2hvb3NlIChwYXJ0IG9mKSBpdHMgb3duIHJlcHJlc2VudGF0aW9uIHN0cmluZyB3aXRoIGFcbiAgICogaGludC4gVGhpcyBtYXkgYmUgdXNlZCB0byBwcm9kdWNlIGFlc3RoZXRpY2FsbHkgcGxlYXNpbmcgYW5kXG4gICAqIHJlY29nbml6YWJsZSB0b2tlbiByZXByZXNlbnRhdGlvbnMgZm9yIGh1bWFucy5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclN0cmluZyh0b2tlbjogVG9rZW4sIHJlcHJlc2VudGF0aW9uSGludD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5yZWdpc3Rlcih0b2tlbiwgcmVwcmVzZW50YXRpb25IaW50KTtcbiAgICByZXR1cm4gYCR7QkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUn0ke2tleX0ke0VORF9UT0tFTl9NQVJLRVJ9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBzdHJpbmcgZm9yIHRoaXMgVG9rZW4sIHJldHVybmluZyBhIGtleVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyTGlzdCh0b2tlbjogVG9rZW4sIHJlcHJlc2VudGF0aW9uSGludD86IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnJlZ2lzdGVyKHRva2VuLCByZXByZXNlbnRhdGlvbkhpbnQpO1xuICAgIHJldHVybiBbYCR7QkVHSU5fTElTVF9UT0tFTl9NQVJLRVJ9JHtrZXl9JHtFTkRfVE9LRU5fTUFSS0VSfWBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBgVG9rZW5TdHJpbmdgIGZvciB0aGlzIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVTdHJpbmdUb2tlblN0cmluZyhzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHMsIEJFR0lOX1NUUklOR19UT0tFTl9NQVJLRVIsIGBbJHtWQUxJRF9LRVlfQ0hBUlN9XStgLCBFTkRfVE9LRU5fTUFSS0VSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYFRva2VuU3RyaW5nYCBmb3IgdGhpcyBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTGlzdFRva2VuU3RyaW5nKHM6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcocywgQkVHSU5fTElTVF9UT0tFTl9NQVJLRVIsIGBbJHtWQUxJRF9LRVlfQ0hBUlN9XStgLCBFTkRfVE9LRU5fTUFSS0VSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGFueSBUb2tlbiBtYXJrZXJzIGluIHRoaXMgc3RyaW5nIHdpdGggdGhlaXIgcmVzb2x2ZWQgdmFsdWVzXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZVN0cmluZ1Rva2VucyhzOiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuY3JlYXRlU3RyaW5nVG9rZW5TdHJpbmcocyk7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gc3RyLnNwbGl0KHRoaXMubG9va3VwVG9rZW4uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50cy5qb2luKCk7XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUxpc3RUb2tlbnMoeHM6IHN0cmluZ1tdKTogYW55IHtcbiAgICAvLyBNdXN0IGJlIGEgc2luZ2xldG9uIGxpc3QgdG9rZW4sIGJlY2F1c2UgY29uY2F0ZW5hdGlvbiBpcyBub3QgYWxsb3dlZC5cbiAgICBpZiAoeHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgZWxlbWVudHMgdG8gbGlzdCB0b2tlbiwgZ290OiAke3hzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ciA9IHRoaXMuY3JlYXRlTGlzdFRva2VuU3RyaW5nKHhzWzBdKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBzdHIuc3BsaXQodGhpcy5sb29rdXBUb2tlbi5iaW5kKHRoaXMpKTtcbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29uY2F0ZW5hdGUgc3RyaW5ncyBpbiBhIHRva2VuaXplZCBzdHJpbmcgYXJyYXksIGdvdDogJHt4c1swXX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50cy52YWx1ZXMoKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgVG9rZW4gYnkga2V5XG4gICAqL1xuICBwdWJsaWMgbG9va3VwVG9rZW4oa2V5OiBzdHJpbmcpOiBUb2tlbiB7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMudG9rZW5NYXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCB0b2tlbiBrZXk6ICR7a2V5fWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2VuTWFwW2tleV07XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVyKHRva2VuOiBUb2tlbiwgcmVwcmVzZW50YXRpb25IaW50Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb3VudGVyID0gT2JqZWN0LmtleXModGhpcy50b2tlbk1hcCkubGVuZ3RoO1xuICAgIGNvbnN0IHJlcHJlc2VudGF0aW9uID0gcmVwcmVzZW50YXRpb25IaW50IHx8IGBUT0tFTmA7XG5cbiAgICBjb25zdCBrZXkgPSBgJHtyZXByZXNlbnRhdGlvbn0uJHtjb3VudGVyfWA7XG4gICAgaWYgKG5ldyBSZWdFeHAoYFteJHtWQUxJRF9LRVlfQ0hBUlN9XWApLmV4ZWMoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdG9rZW4gcmVwcmVzZW50YXRpb246ICR7a2V5fWApO1xuICAgIH1cblxuICAgIHRoaXMudG9rZW5NYXBba2V5XSA9IHRva2VuO1xuICAgIHJldHVybiBrZXk7XG4gIH1cbn1cblxuY29uc3QgQkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUiA9ICcke1Rva2VuWyc7XG5jb25zdCBCRUdJTl9MSVNUX1RPS0VOX01BUktFUiA9ICcje1Rva2VuWyc7XG5jb25zdCBFTkRfVE9LRU5fTUFSS0VSID0gJ119JztcbmNvbnN0IFZBTElEX0tFWV9DSEFSUyA9ICdhLXpBLVowLTk6Ll8tJztcblxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIHRva2VuIHN0cmluZyBtYXBcbiAqL1xuY29uc3QgVE9LRU5fTUFQID0gbmV3IFRva2VuTWFwKCk7XG5cbi8qKlxuICogSW50ZXJmYWNlIHRoYXQgVG9rZW4gam9pbmVycyBpbXBsZW1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVG9rZW5Kb2luZXIge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGpvaW5lci5cbiAgICpcbiAgICogTXVzdCBiZSB1bmlxdWUgcGVyIGpvaW5lcjogdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQgdG8gYXNzZXJ0IHRoYXQgdGhlcmVcbiAgICogaXMgZXhhY3RseSBvbmx5IHR5cGUgb2Ygam9pbmVyIGluIGEgam9pbiBvcGVyYXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhbmd1YWdlIGludHJpbnNpYyB0aGF0IHdpbGwgY29tYmluZSB0aGUgc3RyaW5ncyBpbiB0aGUgZ2l2ZW4gZW5naW5lXG4gICAqL1xuICBqb2luKGZyYWdtZW50czogYW55W10pOiBhbnk7XG59XG5cbi8qKlxuICogQSBzdHJpbmcgd2l0aCBtYXJrZXJzIGluIGl0IHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGV4dGVybmFsIHZhbHVlc1xuICovXG5jbGFzcyBUb2tlblN0cmluZyB7XG4gIHByaXZhdGUgcGF0dGVybjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RyOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBiZWdpbk1hcmtlcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRQYXR0ZXJuOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBlbmRNYXJrZXI6IHN0cmluZykge1xuICAgIHRoaXMucGF0dGVybiA9IGAke3JlZ2V4UXVvdGUodGhpcy5iZWdpbk1hcmtlcil9KCR7dGhpcy5pZFBhdHRlcm59KSR7cmVnZXhRdW90ZSh0aGlzLmVuZE1hcmtlcil9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBzdHJpbmcgb24gbWFya2Vycywgc3Vic3RpdHV0aW5nIG1hcmtlcnMgd2l0aCBUb2tlbnNcbiAgICovXG4gIHB1YmxpYyBzcGxpdChsb29rdXA6IChpZDogc3RyaW5nKSA9PiBUb2tlbik6IFRva2VuU3RyaW5nRnJhZ21lbnRzIHtcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAodGhpcy5wYXR0ZXJuLCAnZycpO1xuICAgIGNvbnN0IHJldCA9IG5ldyBUb2tlblN0cmluZ0ZyYWdtZW50cygpO1xuXG4gICAgbGV0IHJlc3QgPSAwO1xuICAgIGxldCBtID0gcmUuZXhlYyh0aGlzLnN0cik7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGlmIChtLmluZGV4ID4gcmVzdCkge1xuICAgICAgICByZXQuYWRkU3RyaW5nKHRoaXMuc3RyLnN1YnN0cmluZyhyZXN0LCBtLmluZGV4KSk7XG4gICAgICB9XG5cbiAgICAgIHJldC5hZGRUb2tlbihsb29rdXAobVsxXSkpO1xuXG4gICAgICByZXN0ID0gcmUubGFzdEluZGV4O1xuICAgICAgbSA9IHJlLmV4ZWModGhpcy5zdHIpO1xuICAgIH1cblxuICAgIGlmIChyZXN0IDwgdGhpcy5zdHIubGVuZ3RoKSB7XG4gICAgICByZXQuYWRkU3RyaW5nKHRoaXMuc3RyLnN1YnN0cmluZyhyZXN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhpcyBzdHJpbmcgaW5jbHVkZXMgdG9rZW5zLlxuICAgKi9cbiAgcHVibGljIHRlc3QoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybiwgJ2cnKTtcbiAgICByZXR1cm4gcmUudGVzdCh0aGlzLnN0cik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN1bHQgb2YgdGhlIHNwbGl0IG9mIGEgc3RyaW5nIHdpdGggVG9rZW5zXG4gKlxuICogRWl0aGVyIGEgbGl0ZXJhbCBwYXJ0IG9mIHRoZSBzdHJpbmcsIG9yIGFuIHVucmVzb2x2ZWQgVG9rZW4uXG4gKi9cbnR5cGUgU3RyaW5nRnJhZ21lbnQgPSB7IHR5cGU6ICdzdHJpbmcnOyBzdHI6IHN0cmluZyB9O1xudHlwZSBUb2tlbkZyYWdtZW50ID0geyB0eXBlOiAndG9rZW4nOyB0b2tlbjogVG9rZW4gfTtcbnR5cGUgRnJhZ21lbnQgPSAgU3RyaW5nRnJhZ21lbnQgfCBUb2tlbkZyYWdtZW50O1xuXG4vKipcbiAqIEZyYWdtZW50cyBvZiBhIHN0cmluZyB3aXRoIG1hcmtlcnNcbiAqL1xuY2xhc3MgVG9rZW5TdHJpbmdGcmFnbWVudHMge1xuICBwcml2YXRlIHJlYWRvbmx5IGZyYWdtZW50cyA9IG5ldyBBcnJheTxGcmFnbWVudD4oKTtcblxuICBwdWJsaWMgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIHZhbHVlcygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzLm1hcChmID0+IGYudHlwZSA9PT0gJ3Rva2VuJyA/IHJlc29sdmUoZi50b2tlbikgOiBmLnN0cik7XG4gIH1cblxuICBwdWJsaWMgYWRkU3RyaW5nKHN0cjogc3RyaW5nKSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCBzdHIgfSk7XG4gIH1cblxuICBwdWJsaWMgYWRkVG9rZW4odG9rZW46IFRva2VuKSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICd0b2tlbicsIHRva2VuIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGhlIHJlc29sdmVkIHN0cmluZyBmcmFnbWVudHMgdXNpbmcgdGhlIFRva2VucyB0byBqb2luLlxuICAgKlxuICAgKiBSZXNvbHZlcyB0aGUgcmVzdWx0LlxuICAgKi9cbiAgcHVibGljIGpvaW4oKTogYW55IHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIHJlc29sdmVGcmFnbWVudCh0aGlzLmZyYWdtZW50c1swXSk7IH1cblxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5mcmFnbWVudHNbMF07XG5cbiAgICBsZXQgaTtcbiAgICBsZXQgdG9rZW46IFRva2VuO1xuXG4gICAgaWYgKGZpcnN0LnR5cGUgPT09ICd0b2tlbicpIHtcbiAgICAgIHRva2VuID0gZmlyc3QudG9rZW47XG4gICAgICBpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgbmV2ZXIgaGF2ZSB0d28gc3RyaW5ncyBpbiBhIHJvd1xuICAgICAgdG9rZW4gPSAodGhpcy5mcmFnbWVudHNbMV0gYXMgVG9rZW5GcmFnbWVudCkudG9rZW4uY29uY2F0KGZpcnN0LnN0ciwgdW5kZWZpbmVkKTtcbiAgICAgIGkgPSAyO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2VuLmNvbmNhdCh1bmRlZmluZWQsIHJlc29sdmVGcmFnbWVudCh0aGlzLmZyYWdtZW50c1tpXSkpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlKHRva2VuKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHZhbHVlIGZyb20gYSBzaW5nbGUgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCk6IGFueSB7XG4gIHJldHVybiBmcmFnbWVudC50eXBlID09PSAnc3RyaW5nJyA/IGZyYWdtZW50LnN0ciA6IHJlc29sdmUoZnJhZ21lbnQudG9rZW4pO1xufVxuXG4vKipcbiAqIFF1b3RlIGEgc3RyaW5nIGZvciB1c2UgaW4gYSByZWdleFxuICovXG5mdW5jdGlvbiByZWdleFF1b3RlKHM6IHN0cmluZykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csIFwiXFxcXCQmXCIpO1xufVxuIl19