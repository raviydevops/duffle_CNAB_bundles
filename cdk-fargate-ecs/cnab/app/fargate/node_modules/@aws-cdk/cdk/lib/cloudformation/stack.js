"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const app_1 = require("../app");
const construct_1 = require("../core/construct");
const tokens_1 = require("../core/tokens");
const cloudformation_token_1 = require("./cloudformation-token");
const logical_id_1 = require("./logical-id");
/**
 * A root construct which represents a single CloudFormation stack.
 */
class Stack extends construct_1.Construct {
    /**
     * Creates a new stack.
     *
     * @param parent Parent of this stack, usually a Program instance.
     * @param name The name of the CloudFormation stack. Defaults to "Stack".
     * @param props Stack properties.
     */
    constructor(parent, name, props) {
        // For unit test convenience parents are optional, so bypass the type check when calling the parent.
        super(parent, name);
        /**
         * Lists all missing contextual information.
         * This is returned when the stack is synthesized under the 'missing' attribute
         * and allows tooling to obtain the context and re-synthesize.
         */
        this.missingContext = {};
        /**
         * Options for CloudFormation template (like version, transform, description).
         */
        this.templateOptions = {};
        /**
         * Used to determine if this construct is a stack.
         */
        this._isStack = true;
        this.env = this.parseEnvironment(props);
        this.logicalIds = new logical_id_1.LogicalIDs(props && props.namingScheme ? props.namingScheme : new logical_id_1.HashedAddressingScheme());
        this.name = name || 'Stack';
    }
    /**
     * Traverses the tree and looks up for the Stack root.
     * @param node A construct in the tree
     * @returns The Stack object (throws if the node is not part of a Stack-rooted tree)
     */
    static find(node) {
        let curr = node;
        while (curr != null && !Stack.isStack(curr)) {
            curr = curr.parent;
        }
        if (curr == null) {
            throw new Error(`Cannot find a Stack parent for '${node.toString()}'`);
        }
        return curr;
    }
    /**
     * Adds a metadata annotation "aws:cdk:physical-name" to the construct if physicalName
     * is non-null. This can be used later by tools and aspects to determine if resources
     * have been created with physical names.
     */
    static annotatePhysicalName(construct, physicalName) {
        if (physicalName == null) {
            return;
        }
        construct.addMetadata('aws:cdk:physical-name', physicalName);
    }
    /**
     * Return whether the given object is a Stack.
     *
     * We do attribute detection since we can't reliably use 'instanceof'.
     */
    static isStack(construct) {
        return construct._isStack;
    }
    /**
     * Looks up a resource by path.
     *
     * @returns The Resource or undefined if not found
     */
    findResource(path) {
        const r = this.findChild(path);
        if (!r) {
            return undefined;
        }
        // found an element, check if it's a resource (duck-type)
        if (!('resourceType' in r)) {
            throw new Error(`Found a stack element for ${path} but it is not a resource: ${r.toString()}`);
        }
        return r;
    }
    /**
     * Returns the CloudFormation template for this stack by traversing
     * the tree and invoking toCloudFormation() on all Entity objects.
     */
    toCloudFormation() {
        // before we begin synthesis, we shall lock this stack, so children cannot be added
        this.lock();
        try {
            const template = {
                Description: this.templateOptions.description,
                Transform: this.templateOptions.transform,
                AWSTemplateFormatVersion: this.templateOptions.templateFormatVersion,
                Metadata: this.templateOptions.metadata
            };
            const elements = stackElements(this);
            const fragments = elements.map(e => e.toCloudFormation());
            // merge in all CloudFormation fragments collected from the tree
            for (const fragment of fragments) {
                merge(template, fragment);
            }
            // resolve all tokens and remove all empties
            const ret = tokens_1.resolve(template) || {};
            this.logicalIds.assertAllRenamesApplied();
            return ret;
        }
        finally {
            // allow mutations after synthesis is finished.
            this.unlock();
        }
    }
    /**
     * @param why more information about why region is required.
     * @returns The region in which this stack is deployed. Throws if region is not defined.
     */
    requireRegion(why) {
        if (!this.env.region) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires region information. It can be either supplied via the "env" property, ` +
                `via the "${cxapi.DEFAULT_REGION_CONTEXT_KEY}" context parameters or using "aws configure"`);
        }
        return this.env.region;
    }
    /**
     * Returns the AWS account ID of this Stack,
     * or throws an exception if the account ID is not set in the environment.
     *
     * @param why more information about why is the account ID required
     * @returns the AWS account ID of this Stack
     */
    requireAccountId(why) {
        if (!this.env.account) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires account information. ` +
                'It can be supplied either via the "env" property when creating the Stack, or by using "aws configure"');
        }
        return this.env.account;
    }
    parentApp() {
        const parent = this.parent;
        return parent instanceof app_1.App
            ? parent
            : undefined;
    }
    /**
     * Indicate that a context key was expected
     *
     * Contains instructions on how the key should be supplied.
     * @param key Key that uniquely identifies this missing context.
     * @param details The set of parameters needed to obtain the context (specific to context provider).
     */
    reportMissingContext(key, details) {
        this.missingContext[key] = details;
    }
    /**
     * Rename a generated logical identities
     */
    renameLogical(oldId, newId) {
        // tslint:disable-next-line:no-console
        if (this.children.length > 0) {
            throw new Error("All renames must be set up before adding elements to the stack");
        }
        this.logicalIds.renameLogical(oldId, newId);
    }
    /**
     * Validate stack name
     *
     * CloudFormation stack names can include dashes in addition to the regular identifier
     * character classes, and we don't allow one of the magic markers.
     */
    _validateId(name) {
        if (!Stack.VALID_STACK_NAME_REGEX.test(name)) {
            throw new Error(`Stack name must match the regular expression: ${Stack.VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);
        }
    }
    /**
     * Applied defaults to environment attributes.
     */
    parseEnvironment(props) {
        // start with `env`.
        const env = (props && props.env) || {};
        // if account is not specified, attempt to read from context.
        if (!env.account) {
            env.account = this.getContext(cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY);
        }
        // if region is not specified, attempt to read from context.
        if (!env.region) {
            env.region = this.getContext(cxapi.DEFAULT_REGION_CONTEXT_KEY);
        }
        return env;
    }
}
Stack.VALID_STACK_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-]*$/;
exports.Stack = Stack;
function merge(template, part) {
    for (const section of Object.keys(part)) {
        const src = part[section];
        // create top-level section if it doesn't exist
        let dest = template[section];
        if (!dest) {
            template[section] = dest = src;
        }
        else {
            // add all entities from source section to destination section
            for (const id of Object.keys(src)) {
                if (id in dest) {
                    throw new Error(`section '${section}' already contains '${id}'`);
                }
                dest[id] = src[id];
            }
        }
    }
}
const LOGICAL_ID_MD = 'aws:cdk:logicalId';
/**
 * An element of a CloudFormation stack.
 */
class StackElement extends construct_1.Construct {
    /**
     * Returns `true` if a construct is a stack element (i.e. part of the
     * synthesized cloudformation template).
     *
     * Uses duck-typing instead of `instanceof` to allow stack elements from different
     * versions of this library to be included in the same stack.
     *
     * @returns The construct as a stack element or undefined if it is not a stack element.
     */
    static _asStackElement(construct) {
        if ('logicalId' in construct && 'toCloudFormation' in construct) {
            return construct;
        }
        else {
            return undefined;
        }
    }
    /**
     * Creates an entity and binds it to a tree.
     * Note that the root of the tree must be a Stack object (not just any Root).
     *
     * @param parent The parent construct
     * @param props Construct properties
     */
    constructor(parent, name) {
        super(parent, name);
        const s = Stack.find(this);
        if (!s) {
            throw new Error('The tree root must be derived from "Stack"');
        }
        this.stack = s;
        this.addMetadata(LOGICAL_ID_MD, new tokens_1.Token(() => this.logicalId), this.constructor);
        this.logicalId = this.stack.logicalIds.getLogicalId(this);
    }
    /**
     * @returns the stack trace of the point where this Resource was created from, sourced
     *      from the +metadata+ entry typed +aws:cdk:logicalId+, and with the bottom-most
     *      node +internal+ entries filtered.
     */
    get creationStackTrace() {
        return filterStackTrace(this.metadata.find(md => md.type === LOGICAL_ID_MD).trace);
        function filterStackTrace(stack) {
            const result = Array.of(...stack);
            while (result.length > 0 && shouldFilter(result[result.length - 1])) {
                result.pop();
            }
            // It's weird if we filtered everything, so return the whole stack...
            return result.length === 0 ? stack : result;
        }
        function shouldFilter(str) {
            return str.match(/[^(]+\(internal\/.*/) !== null;
        }
    }
    /**
     * Return the path with respect to the stack
     */
    get stackPath() {
        return this.ancestors(this.stack).map(c => c.id).join(construct_1.PATH_SEP);
    }
    get dependencyElements() {
        return [this];
    }
}
exports.StackElement = StackElement;
/**
 * Base class for referenceable CloudFormation constructs which are not Resources
 *
 * These constructs are things like Conditions and Parameters, can be
 * referenced by taking the `.ref` attribute.
 *
 * Resource constructs do not inherit from Referenceable because they have their
 * own, more specific types returned from the .ref attribute. Also, some
 * resources aren't referenceable at all (such as BucketPolicies or GatewayAttachments).
 */
class Referenceable extends StackElement {
    /**
     * Returns a token to a CloudFormation { Ref } that references this entity based on it's logical ID.
     */
    get ref() {
        return new Ref(this).toString();
    }
}
exports.Referenceable = Referenceable;
/**
 * Collect all StackElements from a construct
 *
 * @param node Root node to collect all StackElements from
 * @param into Array to append StackElements to
 * @returns The same array as is being collected into
 */
function stackElements(node, into = []) {
    const element = StackElement._asStackElement(node);
    if (element) {
        into.push(element);
    }
    for (const child of node.children) {
        stackElements(child, into);
    }
    return into;
}
/**
 * A generic, untyped reference to a Stack Element
 */
class Ref extends cloudformation_token_1.CloudFormationToken {
    constructor(element) {
        super({ Ref: element.logicalId }, `${element.logicalId}.Ref`);
    }
}
exports.Ref = Ref;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUEwQztBQUMxQyxnQ0FBNkI7QUFDN0IsaURBQXdEO0FBQ3hELDJDQUFnRDtBQUVoRCxpRUFBNkQ7QUFDN0QsNkNBQXFGO0FBb0JyRjs7R0FFRztBQUNILE1BQWEsS0FBTSxTQUFRLHFCQUFTO0lBMEVsQzs7Ozs7O09BTUc7SUFDSCxZQUFtQixNQUFZLEVBQUUsSUFBYSxFQUFFLEtBQWtCO1FBQ2hFLG9HQUFvRztRQUNwRyxLQUFLLENBQUMsTUFBTyxFQUFFLElBQUssQ0FBQyxDQUFDO1FBekN4Qjs7OztXQUlHO1FBQ2EsbUJBQWMsR0FBNEMsRUFBRyxDQUFDO1FBWTlFOztXQUVHO1FBQ2Esb0JBQWUsR0FBb0IsRUFBRSxDQUFDO1FBT3REOztXQUVHO1FBQ2dCLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFZakMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHVCQUFVLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksbUNBQXNCLEVBQUUsQ0FBQyxDQUFDO1FBQ2xILElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLE9BQU8sQ0FBQztJQUM5QixDQUFDO0lBdkZEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQWU7UUFDaEMsSUFBSSxJQUFJLEdBQTBCLElBQUksQ0FBQztRQUN2QyxPQUFPLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxJQUFJ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QyxDQUFDO0lBQ25ELElBQUksT0FBTyxFQUFFO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNwQjtJQUVELEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNqQyxhQUFhLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLEdBQUksU0FBUSwwQ0FBbUI7SUFDMUMsWUFBWSxPQUFxQjtRQUMvQixLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLFNBQVMsTUFBTSxDQUFDLENBQUM7SUFDaEUsQ0FBQztDQUNGO0FBSkQsa0JBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4uL2FwcCc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIFBBVEhfU0VQIH0gZnJvbSAnLi4vY29yZS9jb25zdHJ1Y3QnO1xuaW1wb3J0IHsgcmVzb2x2ZSwgVG9rZW4gfSBmcm9tICcuLi9jb3JlL3Rva2Vucyc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCB9IGZyb20gJy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uVG9rZW4gfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uLXRva2VuJztcbmltcG9ydCB7IEhhc2hlZEFkZHJlc3NpbmdTY2hlbWUsIElBZGRyZXNzaW5nU2NoZW1lLCBMb2dpY2FsSURzIH0gZnJvbSAnLi9sb2dpY2FsLWlkJztcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2tQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgQVdTIGVudmlyb25tZW50IChhY2NvdW50L3JlZ2lvbikgd2hlcmUgdGhpcyBzdGFjayB3aWxsIGJlIGRlcGxveWVkLlxuICAgKlxuICAgKiBJZiBub3Qgc3VwcGxpZWQsIHRoZSBgZGVmYXVsdC1hY2NvdW50YCBhbmQgYGRlZmF1bHQtcmVnaW9uYCBjb250ZXh0IHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgKiB1c2VkLiBJZiB0aGV5IGFyZSB1bmRlZmluZWQsIGl0IHdpbGwgbm90IGJlIHBvc3NpYmxlIHRvIGRlcGxveSB0aGUgc3RhY2suXG4gICAqL1xuICBlbnY/OiBFbnZpcm9ubWVudDtcblxuICAvKipcbiAgICogU3RyYXRlZ3kgZm9yIGxvZ2ljYWwgSUQgZ2VuZXJhdGlvblxuICAgKlxuICAgKiBPcHRpb25hbC4gSWYgbm90IHN1cHBsaWVkLCB0aGUgSGFzaGVkTmFtaW5nU2NoZW1lIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG5hbWluZ1NjaGVtZT86IElBZGRyZXNzaW5nU2NoZW1lO1xufVxuXG4vKipcbiAqIEEgcm9vdCBjb25zdHJ1Y3Qgd2hpY2ggcmVwcmVzZW50cyBhIHNpbmdsZSBDbG91ZEZvcm1hdGlvbiBzdGFjay5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YWNrIGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBhbmQgbG9va3MgdXAgZm9yIHRoZSBTdGFjayByb290LlxuICAgKiBAcGFyYW0gbm9kZSBBIGNvbnN0cnVjdCBpbiB0aGUgdHJlZVxuICAgKiBAcmV0dXJucyBUaGUgU3RhY2sgb2JqZWN0ICh0aHJvd3MgaWYgdGhlIG5vZGUgaXMgbm90IHBhcnQgb2YgYSBTdGFjay1yb290ZWQgdHJlZSlcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZmluZChub2RlOiBDb25zdHJ1Y3QpOiBTdGFjayB7XG4gICAgbGV0IGN1cnI6IENvbnN0cnVjdCB8IHVuZGVmaW5lZCA9IG5vZGU7XG4gICAgd2hpbGUgKGN1cnIgIT0gbnVsbCAmJiAhU3RhY2suaXNTdGFjayhjdXJyKSkge1xuICAgICAgY3VyciA9IGN1cnIucGFyZW50O1xuICAgIH1cblxuICAgIGlmIChjdXJyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYSBTdGFjayBwYXJlbnQgZm9yICcke25vZGUudG9TdHJpbmcoKX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBtZXRhZGF0YSBhbm5vdGF0aW9uIFwiYXdzOmNkazpwaHlzaWNhbC1uYW1lXCIgdG8gdGhlIGNvbnN0cnVjdCBpZiBwaHlzaWNhbE5hbWVcbiAgICogaXMgbm9uLW51bGwuIFRoaXMgY2FuIGJlIHVzZWQgbGF0ZXIgYnkgdG9vbHMgYW5kIGFzcGVjdHMgdG8gZGV0ZXJtaW5lIGlmIHJlc291cmNlc1xuICAgKiBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIHBoeXNpY2FsIG5hbWVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhbm5vdGF0ZVBoeXNpY2FsTmFtZShjb25zdHJ1Y3Q6IENvbnN0cnVjdCwgcGh5c2ljYWxOYW1lPzogc3RyaW5nKSB7XG4gICAgaWYgKHBoeXNpY2FsTmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3RydWN0LmFkZE1ldGFkYXRhKCdhd3M6Y2RrOnBoeXNpY2FsLW5hbWUnLCBwaHlzaWNhbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBTdGFjay5cbiAgICpcbiAgICogV2UgZG8gYXR0cmlidXRlIGRldGVjdGlvbiBzaW5jZSB3ZSBjYW4ndCByZWxpYWJseSB1c2UgJ2luc3RhbmNlb2YnLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc1N0YWNrKGNvbnN0cnVjdDogQ29uc3RydWN0KTogY29uc3RydWN0IGlzIFN0YWNrIHtcbiAgICByZXR1cm4gKGNvbnN0cnVjdCBhcyBhbnkpLl9pc1N0YWNrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVkFMSURfU1RBQ0tfTkFNRV9SRUdFWCA9IC9eW0EtWmEtel1bQS1aYS16MC05LV0qJC87XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBtaXNzaW5nIGNvbnRleHR1YWwgaW5mb3JtYXRpb24uXG4gICAqIFRoaXMgaXMgcmV0dXJuZWQgd2hlbiB0aGUgc3RhY2sgaXMgc3ludGhlc2l6ZWQgdW5kZXIgdGhlICdtaXNzaW5nJyBhdHRyaWJ1dGVcbiAgICogYW5kIGFsbG93cyB0b29saW5nIHRvIG9idGFpbiB0aGUgY29udGV4dCBhbmQgcmUtc3ludGhlc2l6ZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtaXNzaW5nQ29udGV4dDogeyBba2V5OiBzdHJpbmddOiBjeGFwaS5NaXNzaW5nQ29udGV4dCB9ID0geyB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhpcyBzdGFjayBpcyBkZXBsb3llZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBlbnY6IEVudmlyb25tZW50O1xuXG4gIC8qKlxuICAgKiBMb2dpY2FsIElEIGdlbmVyYXRpb24gc3RyYXRlZ3lcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsb2dpY2FsSWRzOiBMb2dpY2FsSURzO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSAobGlrZSB2ZXJzaW9uLCB0cmFuc2Zvcm0sIGRlc2NyaXB0aW9uKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB0ZW1wbGF0ZU9wdGlvbnM6IFRlbXBsYXRlT3B0aW9ucyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgQ2xvdWRGb3JtYXRpb24gc3RhY2sgbmFtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgY29uc3RydWN0IGlzIGEgc3RhY2suXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2lzU3RhY2sgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBvZiB0aGlzIHN0YWNrLCB1c3VhbGx5IGEgUHJvZ3JhbSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIENsb3VkRm9ybWF0aW9uIHN0YWNrLiBEZWZhdWx0cyB0byBcIlN0YWNrXCIuXG4gICAqIEBwYXJhbSBwcm9wcyBTdGFjayBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHBhcmVudD86IEFwcCwgbmFtZT86IHN0cmluZywgcHJvcHM/OiBTdGFja1Byb3BzKSB7XG4gICAgLy8gRm9yIHVuaXQgdGVzdCBjb252ZW5pZW5jZSBwYXJlbnRzIGFyZSBvcHRpb25hbCwgc28gYnlwYXNzIHRoZSB0eXBlIGNoZWNrIHdoZW4gY2FsbGluZyB0aGUgcGFyZW50LlxuICAgIHN1cGVyKHBhcmVudCEsIG5hbWUhKTtcbiAgICB0aGlzLmVudiA9IHRoaXMucGFyc2VFbnZpcm9ubWVudChwcm9wcyk7XG5cbiAgICB0aGlzLmxvZ2ljYWxJZHMgPSBuZXcgTG9naWNhbElEcyhwcm9wcyAmJiBwcm9wcy5uYW1pbmdTY2hlbWUgPyBwcm9wcy5uYW1pbmdTY2hlbWUgOiBuZXcgSGFzaGVkQWRkcmVzc2luZ1NjaGVtZSgpKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdTdGFjayc7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdXAgYSByZXNvdXJjZSBieSBwYXRoLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgUmVzb3VyY2Ugb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGZpbmRSZXNvdXJjZShwYXRoOiBzdHJpbmcpOiBSZXNvdXJjZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgciA9IHRoaXMuZmluZENoaWxkKHBhdGgpO1xuICAgIGlmICghcikgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAvLyBmb3VuZCBhbiBlbGVtZW50LCBjaGVjayBpZiBpdCdzIGEgcmVzb3VyY2UgKGR1Y2stdHlwZSlcbiAgICBpZiAoISgncmVzb3VyY2VUeXBlJyBpbiByKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBhIHN0YWNrIGVsZW1lbnQgZm9yICR7cGF0aH0gYnV0IGl0IGlzIG5vdCBhIHJlc291cmNlOiAke3IudG9TdHJpbmcoKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciBhcyBSZXNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBmb3IgdGhpcyBzdGFjayBieSB0cmF2ZXJzaW5nXG4gICAqIHRoZSB0cmVlIGFuZCBpbnZva2luZyB0b0Nsb3VkRm9ybWF0aW9uKCkgb24gYWxsIEVudGl0eSBvYmplY3RzLlxuICAgKi9cbiAgcHVibGljIHRvQ2xvdWRGb3JtYXRpb24oKSB7XG4gICAgLy8gYmVmb3JlIHdlIGJlZ2luIHN5bnRoZXNpcywgd2Ugc2hhbGwgbG9jayB0aGlzIHN0YWNrLCBzbyBjaGlsZHJlbiBjYW5ub3QgYmUgYWRkZWRcbiAgICB0aGlzLmxvY2soKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZTogYW55ID0ge1xuICAgICAgICBEZXNjcmlwdGlvbjogdGhpcy50ZW1wbGF0ZU9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgIFRyYW5zZm9ybTogdGhpcy50ZW1wbGF0ZU9wdGlvbnMudHJhbnNmb3JtLFxuICAgICAgICBBV1NUZW1wbGF0ZUZvcm1hdFZlcnNpb246IHRoaXMudGVtcGxhdGVPcHRpb25zLnRlbXBsYXRlRm9ybWF0VmVyc2lvbixcbiAgICAgICAgTWV0YWRhdGE6IHRoaXMudGVtcGxhdGVPcHRpb25zLm1ldGFkYXRhXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbGVtZW50cyA9IHN0YWNrRWxlbWVudHModGhpcyk7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSBlbGVtZW50cy5tYXAoZSA9PiBlLnRvQ2xvdWRGb3JtYXRpb24oKSk7XG5cbiAgICAgIC8vIG1lcmdlIGluIGFsbCBDbG91ZEZvcm1hdGlvbiBmcmFnbWVudHMgY29sbGVjdGVkIGZyb20gdGhlIHRyZWVcbiAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgZnJhZ21lbnRzKSB7XG4gICAgICAgIG1lcmdlKHRlbXBsYXRlLCBmcmFnbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc29sdmUgYWxsIHRva2VucyBhbmQgcmVtb3ZlIGFsbCBlbXB0aWVzXG4gICAgICBjb25zdCByZXQgPSByZXNvbHZlKHRlbXBsYXRlKSB8fCB7IH07XG5cbiAgICAgIHRoaXMubG9naWNhbElkcy5hc3NlcnRBbGxSZW5hbWVzQXBwbGllZCgpO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbGxvdyBtdXRhdGlvbnMgYWZ0ZXIgc3ludGhlc2lzIGlzIGZpbmlzaGVkLlxuICAgICAgdGhpcy51bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHdoeSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoeSByZWdpb24gaXMgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIFRoZSByZWdpb24gaW4gd2hpY2ggdGhpcyBzdGFjayBpcyBkZXBsb3llZC4gVGhyb3dzIGlmIHJlZ2lvbiBpcyBub3QgZGVmaW5lZC5cbiAgICovXG4gIHB1YmxpYyByZXF1aXJlUmVnaW9uKHdoeT86IHN0cmluZykge1xuICAgIGlmICghdGhpcy5lbnYucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7d2h5ID8gd2h5ICsgJy4gJyA6ICcnfVN0YWNrIHJlcXVpcmVzIHJlZ2lvbiBpbmZvcm1hdGlvbi4gSXQgY2FuIGJlIGVpdGhlciBzdXBwbGllZCB2aWEgdGhlIFwiZW52XCIgcHJvcGVydHksIGAgK1xuICAgICAgICAgIGB2aWEgdGhlIFwiJHtjeGFwaS5ERUZBVUxUX1JFR0lPTl9DT05URVhUX0tFWX1cIiBjb250ZXh0IHBhcmFtZXRlcnMgb3IgdXNpbmcgXCJhd3MgY29uZmlndXJlXCJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbnYucmVnaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEFXUyBhY2NvdW50IElEIG9mIHRoaXMgU3RhY2ssXG4gICAqIG9yIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGFjY291bnQgSUQgaXMgbm90IHNldCBpbiB0aGUgZW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB3aHkgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aHkgaXMgdGhlIGFjY291bnQgSUQgcmVxdWlyZWRcbiAgICogQHJldHVybnMgdGhlIEFXUyBhY2NvdW50IElEIG9mIHRoaXMgU3RhY2tcbiAgICovXG4gIHB1YmxpYyByZXF1aXJlQWNjb3VudElkKHdoeT86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmVudi5hY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7d2h5ID8gd2h5ICsgJy4gJyA6ICcnfVN0YWNrIHJlcXVpcmVzIGFjY291bnQgaW5mb3JtYXRpb24uIGAgK1xuICAgICAgICAnSXQgY2FuIGJlIHN1cHBsaWVkIGVpdGhlciB2aWEgdGhlIFwiZW52XCIgcHJvcGVydHkgd2hlbiBjcmVhdGluZyB0aGUgU3RhY2ssIG9yIGJ5IHVzaW5nIFwiYXdzIGNvbmZpZ3VyZVwiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW52LmFjY291bnQ7XG4gIH1cblxuICBwdWJsaWMgcGFyZW50QXBwKCk6IEFwcCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgcmV0dXJuIHBhcmVudCBpbnN0YW5jZW9mIEFwcFxuICAgICAgPyBwYXJlbnRcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHRoYXQgYSBjb250ZXh0IGtleSB3YXMgZXhwZWN0ZWRcbiAgICpcbiAgICogQ29udGFpbnMgaW5zdHJ1Y3Rpb25zIG9uIGhvdyB0aGUga2V5IHNob3VsZCBiZSBzdXBwbGllZC5cbiAgICogQHBhcmFtIGtleSBLZXkgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoaXMgbWlzc2luZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gZGV0YWlscyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgbmVlZGVkIHRvIG9idGFpbiB0aGUgY29udGV4dCAoc3BlY2lmaWMgdG8gY29udGV4dCBwcm92aWRlcikuXG4gICAqL1xuICBwdWJsaWMgcmVwb3J0TWlzc2luZ0NvbnRleHQoa2V5OiBzdHJpbmcsIGRldGFpbHM6IGN4YXBpLk1pc3NpbmdDb250ZXh0KSB7XG4gICAgdGhpcy5taXNzaW5nQ29udGV4dFtrZXldID0gZGV0YWlscztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgYSBnZW5lcmF0ZWQgbG9naWNhbCBpZGVudGl0aWVzXG4gICAqL1xuICBwdWJsaWMgcmVuYW1lTG9naWNhbChvbGRJZDogc3RyaW5nLCBuZXdJZDogc3RyaW5nKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgcmVuYW1lcyBtdXN0IGJlIHNldCB1cCBiZWZvcmUgYWRkaW5nIGVsZW1lbnRzIHRvIHRoZSBzdGFja1wiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2ljYWxJZHMucmVuYW1lTG9naWNhbChvbGRJZCwgbmV3SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHN0YWNrIG5hbWVcbiAgICpcbiAgICogQ2xvdWRGb3JtYXRpb24gc3RhY2sgbmFtZXMgY2FuIGluY2x1ZGUgZGFzaGVzIGluIGFkZGl0aW9uIHRvIHRoZSByZWd1bGFyIGlkZW50aWZpZXJcbiAgICogY2hhcmFjdGVyIGNsYXNzZXMsIGFuZCB3ZSBkb24ndCBhbGxvdyBvbmUgb2YgdGhlIG1hZ2ljIG1hcmtlcnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlSWQobmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKCFTdGFjay5WQUxJRF9TVEFDS19OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhY2sgbmFtZSBtdXN0IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb246ICR7U3RhY2suVkFMSURfU1RBQ0tfTkFNRV9SRUdFWC50b1N0cmluZygpfSwgZ290ICcke25hbWV9J2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVkIGRlZmF1bHRzIHRvIGVudmlyb25tZW50IGF0dHJpYnV0ZXMuXG4gICAqL1xuICBwcml2YXRlIHBhcnNlRW52aXJvbm1lbnQocHJvcHM/OiBTdGFja1Byb3BzKSB7XG4gICAgLy8gc3RhcnQgd2l0aCBgZW52YC5cbiAgICBjb25zdCBlbnY6IEVudmlyb25tZW50ID0gKHByb3BzICYmIHByb3BzLmVudikgfHwgeyB9O1xuXG4gICAgLy8gaWYgYWNjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCBhdHRlbXB0IHRvIHJlYWQgZnJvbSBjb250ZXh0LlxuICAgIGlmICghZW52LmFjY291bnQpIHtcbiAgICAgIGVudi5hY2NvdW50ID0gdGhpcy5nZXRDb250ZXh0KGN4YXBpLkRFRkFVTFRfQUNDT1VOVF9DT05URVhUX0tFWSk7XG4gICAgfVxuXG4gICAgLy8gaWYgcmVnaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGF0dGVtcHQgdG8gcmVhZCBmcm9tIGNvbnRleHQuXG4gICAgaWYgKCFlbnYucmVnaW9uKSB7XG4gICAgICBlbnYucmVnaW9uID0gdGhpcy5nZXRDb250ZXh0KGN4YXBpLkRFRkFVTFRfUkVHSU9OX0NPTlRFWFRfS0VZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW52O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlKHRlbXBsYXRlOiBhbnksIHBhcnQ6IGFueSkge1xuICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgT2JqZWN0LmtleXMocGFydCkpIHtcbiAgICBjb25zdCBzcmMgPSBwYXJ0W3NlY3Rpb25dO1xuXG4gICAgLy8gY3JlYXRlIHRvcC1sZXZlbCBzZWN0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBsZXQgZGVzdCA9IHRlbXBsYXRlW3NlY3Rpb25dO1xuICAgIGlmICghZGVzdCkge1xuICAgICAgdGVtcGxhdGVbc2VjdGlvbl0gPSBkZXN0ID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgYWxsIGVudGl0aWVzIGZyb20gc291cmNlIHNlY3Rpb24gdG8gZGVzdGluYXRpb24gc2VjdGlvblxuICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhzcmMpKSB7XG4gICAgICAgIGlmIChpZCBpbiBkZXN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZWN0aW9uICcke3NlY3Rpb259JyBhbHJlYWR5IGNvbnRhaW5zICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0W2lkXSA9IHNyY1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IExPR0lDQUxfSURfTUQgPSAnYXdzOmNkazpsb2dpY2FsSWQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb25zdHJ1Y3QgdGhhdCBjYW4gYmUgXCJkZXBlbmRlZCBvblwiIHZpYSBgYWRkRGVwZW5kZW5jeWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSURlcGVuZGFibGUge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2V0IG9mIGFsbCBzdGFjayBlbGVtZW50cyAocmVzb3VyY2VzLCBwYXJhbWV0ZXJzLCBjb25kaXRpb25zKVxuICAgKiB0aGF0IHNob3VsZCBiZSBhZGRlZCB3aGVuIGEgcmVzb3VyY2UgXCJkZXBlbmRzIG9uXCIgdGhpcyBjb25zdHJ1Y3QuXG4gICAqL1xuICByZWFkb25seSBkZXBlbmRlbmN5RWxlbWVudHM6IElEZXBlbmRhYmxlW107XG59XG5cbi8qKlxuICogQW4gZWxlbWVudCBvZiBhIENsb3VkRm9ybWF0aW9uIHN0YWNrLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RhY2tFbGVtZW50IGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSURlcGVuZGFibGUge1xuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYSBjb25zdHJ1Y3QgaXMgYSBzdGFjayBlbGVtZW50IChpLmUuIHBhcnQgb2YgdGhlXG4gICAqIHN5bnRoZXNpemVkIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlKS5cbiAgICpcbiAgICogVXNlcyBkdWNrLXR5cGluZyBpbnN0ZWFkIG9mIGBpbnN0YW5jZW9mYCB0byBhbGxvdyBzdGFjayBlbGVtZW50cyBmcm9tIGRpZmZlcmVudFxuICAgKiB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHNhbWUgc3RhY2suXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3QgYXMgYSBzdGFjayBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBub3QgYSBzdGFjayBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBfYXNTdGFja0VsZW1lbnQoY29uc3RydWN0OiBDb25zdHJ1Y3QpOiBTdGFja0VsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgIGlmICgnbG9naWNhbElkJyBpbiBjb25zdHJ1Y3QgJiYgJ3RvQ2xvdWRGb3JtYXRpb24nIGluIGNvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdCBhcyBTdGFja0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsb2dpY2FsIElEIGZvciB0aGlzIENsb3VkRm9ybWF0aW9uIHN0YWNrIGVsZW1lbnRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN0YWNrIHRoaXMgQ29uc3RydWN0IGhhcyBiZWVuIG1hZGUgYSBwYXJ0IG9mXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RhY2s6IFN0YWNrO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVudGl0eSBhbmQgYmluZHMgaXQgdG8gYSB0cmVlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHJvb3Qgb2YgdGhlIHRyZWUgbXVzdCBiZSBhIFN0YWNrIG9iamVjdCAobm90IGp1c3QgYW55IFJvb3QpLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgY29uc3RydWN0XG4gICAqIEBwYXJhbSBwcm9wcyBDb25zdHJ1Y3QgcHJvcGVydGllc1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50OiBDb25zdHJ1Y3QsIG5hbWU6IHN0cmluZykge1xuICAgIHN1cGVyKHBhcmVudCwgbmFtZSk7XG4gICAgY29uc3QgcyA9IFN0YWNrLmZpbmQodGhpcyk7XG4gICAgaWYgKCFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmVlIHJvb3QgbXVzdCBiZSBkZXJpdmVkIGZyb20gXCJTdGFja1wiJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sgPSBzO1xuXG4gICAgdGhpcy5hZGRNZXRhZGF0YShMT0dJQ0FMX0lEX01ELCBuZXcgVG9rZW4oKCkgPT4gdGhpcy5sb2dpY2FsSWQpLCB0aGlzLmNvbnN0cnVjdG9yKTtcblxuICAgIHRoaXMubG9naWNhbElkID0gdGhpcy5zdGFjay5sb2dpY2FsSWRzLmdldExvZ2ljYWxJZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB0aGUgc3RhY2sgdHJhY2Ugb2YgdGhlIHBvaW50IHdoZXJlIHRoaXMgUmVzb3VyY2Ugd2FzIGNyZWF0ZWQgZnJvbSwgc291cmNlZFxuICAgKiAgICAgIGZyb20gdGhlICttZXRhZGF0YSsgZW50cnkgdHlwZWQgK2F3czpjZGs6bG9naWNhbElkKywgYW5kIHdpdGggdGhlIGJvdHRvbS1tb3N0XG4gICAqICAgICAgbm9kZSAraW50ZXJuYWwrIGVudHJpZXMgZmlsdGVyZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNyZWF0aW9uU3RhY2tUcmFjZSgpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIGZpbHRlclN0YWNrVHJhY2UodGhpcy5tZXRhZGF0YS5maW5kKG1kID0+IG1kLnR5cGUgPT09IExPR0lDQUxfSURfTUQpIS50cmFjZSk7XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJTdGFja1RyYWNlKHN0YWNrOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5Lm9mKC4uLnN0YWNrKTtcbiAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoID4gMCAmJiBzaG91bGRGaWx0ZXIocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gSXQncyB3ZWlyZCBpZiB3ZSBmaWx0ZXJlZCBldmVyeXRoaW5nLCBzbyByZXR1cm4gdGhlIHdob2xlIHN0YWNrLi4uXG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IHN0YWNrIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEZpbHRlcihzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvW14oXStcXChpbnRlcm5hbFxcLy4qLykgIT09IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcGF0aCB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFuY2VzdG9ycyh0aGlzLnN0YWNrKS5tYXAoYyA9PiBjLmlkKS5qb2luKFBBVEhfU0VQKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVwZW5kZW5jeUVsZW1lbnRzKCk6IElEZXBlbmRhYmxlW10ge1xuICAgIHJldHVybiBbIHRoaXMgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDbG91ZEZvcm1hdGlvbiAnc25pcHBldCcgZm9yIHRoaXMgZW50aXR5LiBUaGUgc25pcHBldCB3aWxsIG9ubHkgYmUgbWVyZ2VkXG4gICAqIGF0IHRoZSByb290IGxldmVsIHRvIGVuc3VyZSB0aGVyZSBhcmUgbm8gaWRlbnRpdHkgY29uZmxpY3RzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgYSBSZXNvdXJjZSBjbGFzcyB3aWxsIHJldHVybiBzb21ldGhpbmcgbGlrZTpcbiAgICoge1xuICAgKiAgIFJlc291cmNlczoge1xuICAgKiAgICAgW3RoaXMubG9naWNhbElkXToge1xuICAgKiAgICAgICBUeXBlOiB0aGlzLnJlc291cmNlVHlwZSxcbiAgICogICAgICAgUHJvcGVydGllczogdGhpcy5wcm9wcyxcbiAgICogICAgICAgQ29uZGl0aW9uOiB0aGlzLmNvbmRpdGlvblxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHRvQ2xvdWRGb3JtYXRpb24oKTogb2JqZWN0O1xufVxuXG4vKipcbiAqIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIG9wdGlvbnMgZm9yIGEgc3RhY2suXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgZGVzY3JpcHRpb24gb2YgdGhpcyBzdGFjay5cbiAgICogSWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlJ3MgXCJEZXNjcmlwdGlvblwiIGF0dHJpYnV0ZS5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIEFXU1RlbXBsYXRlRm9ybWF0VmVyc2lvbiBmaWVsZCBvZiB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUuXG4gICAqL1xuICB0ZW1wbGF0ZUZvcm1hdFZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgdG9wLWxldmVsIHRlbXBsYXRlIHRyYW5zZm9ybSBmb3IgdGhpcyBzdGFjayAoZS5nLiBcIkFXUzo6U2VydmVybGVzcy0yMDE2LTEwLTMxXCIpLlxuICAgKi9cbiAgdHJhbnNmb3JtPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgKi9cbiAgIG1ldGFkYXRhPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciByZWZlcmVuY2VhYmxlIENsb3VkRm9ybWF0aW9uIGNvbnN0cnVjdHMgd2hpY2ggYXJlIG5vdCBSZXNvdXJjZXNcbiAqXG4gKiBUaGVzZSBjb25zdHJ1Y3RzIGFyZSB0aGluZ3MgbGlrZSBDb25kaXRpb25zIGFuZCBQYXJhbWV0ZXJzLCBjYW4gYmVcbiAqIHJlZmVyZW5jZWQgYnkgdGFraW5nIHRoZSBgLnJlZmAgYXR0cmlidXRlLlxuICpcbiAqIFJlc291cmNlIGNvbnN0cnVjdHMgZG8gbm90IGluaGVyaXQgZnJvbSBSZWZlcmVuY2VhYmxlIGJlY2F1c2UgdGhleSBoYXZlIHRoZWlyXG4gKiBvd24sIG1vcmUgc3BlY2lmaWMgdHlwZXMgcmV0dXJuZWQgZnJvbSB0aGUgLnJlZiBhdHRyaWJ1dGUuIEFsc28sIHNvbWVcbiAqIHJlc291cmNlcyBhcmVuJ3QgcmVmZXJlbmNlYWJsZSBhdCBhbGwgKHN1Y2ggYXMgQnVja2V0UG9saWNpZXMgb3IgR2F0ZXdheUF0dGFjaG1lbnRzKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZmVyZW5jZWFibGUgZXh0ZW5kcyBTdGFja0VsZW1lbnQge1xuICAvKipcbiAgICogUmV0dXJucyBhIHRva2VuIHRvIGEgQ2xvdWRGb3JtYXRpb24geyBSZWYgfSB0aGF0IHJlZmVyZW5jZXMgdGhpcyBlbnRpdHkgYmFzZWQgb24gaXQncyBsb2dpY2FsIElELlxuICAgKi9cbiAgcHVibGljIGdldCByZWYoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IFJlZih0aGlzKS50b1N0cmluZygpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBhbGwgU3RhY2tFbGVtZW50cyBmcm9tIGEgY29uc3RydWN0XG4gKlxuICogQHBhcmFtIG5vZGUgUm9vdCBub2RlIHRvIGNvbGxlY3QgYWxsIFN0YWNrRWxlbWVudHMgZnJvbVxuICogQHBhcmFtIGludG8gQXJyYXkgdG8gYXBwZW5kIFN0YWNrRWxlbWVudHMgdG9cbiAqIEByZXR1cm5zIFRoZSBzYW1lIGFycmF5IGFzIGlzIGJlaW5nIGNvbGxlY3RlZCBpbnRvXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRWxlbWVudHMobm9kZTogQ29uc3RydWN0LCBpbnRvOiBTdGFja0VsZW1lbnRbXSA9IFtdKTogU3RhY2tFbGVtZW50W10ge1xuICBjb25zdCBlbGVtZW50ID0gU3RhY2tFbGVtZW50Ll9hc1N0YWNrRWxlbWVudChub2RlKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICBpbnRvLnB1c2goZWxlbWVudCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBzdGFja0VsZW1lbnRzKGNoaWxkLCBpbnRvKTtcbiAgfVxuXG4gIHJldHVybiBpbnRvO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYywgdW50eXBlZCByZWZlcmVuY2UgdG8gYSBTdGFjayBFbGVtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWYgZXh0ZW5kcyBDbG91ZEZvcm1hdGlvblRva2VuIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudDogU3RhY2tFbGVtZW50KSB7XG4gICAgc3VwZXIoeyBSZWY6IGVsZW1lbnQubG9naWNhbElkIH0sIGAke2VsZW1lbnQubG9naWNhbElkfS5SZWZgKTtcbiAgfVxufVxuIl19