"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs");
const path = require("path");
const stack_1 = require("./cloudformation/stack");
const construct_1 = require("./core/construct");
const tokens_1 = require("./core/tokens");
/**
 * Represents a CDK program.
 */
class App extends construct_1.Root {
    /**
     * Initializes a CDK application.
     * @param request Optional toolkit request (e.g. for tests)
     */
    constructor() {
        super();
        this.loadContext();
    }
    get stacks() {
        const out = {};
        for (const child of this.children) {
            if (!stack_1.Stack.isStack(child)) {
                throw new Error(`The child ${child.toString()} of App must be a Stack`);
            }
            out[child.id] = child;
        }
        return out;
    }
    /**
     * Runs the program. Output is written to output directory as specified in the request.
     */
    run() {
        const outdir = process.env[cxapi.OUTDIR_ENV];
        if (!outdir) {
            process.stderr.write(`ERROR: The environment variable "${cxapi.OUTDIR_ENV}" is not defined\n`);
            process.stderr.write('AWS CDK Toolkit (>= 0.11.0) is required in order to interact with this program.\n');
            process.exit(1);
            return;
        }
        const result = {
            version: cxapi.PROTO_RESPONSE_VERSION,
            stacks: this.synthesizeStacks(Object.keys(this.stacks)),
            runtime: this.collectRuntimeInformation()
        };
        const outfile = path.join(outdir, cxapi.OUTFILE_NAME);
        fs.writeFileSync(outfile, JSON.stringify(result, undefined, 2));
    }
    /**
     * Synthesize and validate a single stack
     * @param stackName The name of the stack to synthesize
     */
    synthesizeStack(stackName) {
        const stack = this.getStack(stackName);
        // first, validate this stack and stop if there are errors.
        const errors = stack.validateTree();
        if (errors.length > 0) {
            const errorList = errors.map(e => `[${e.source.path}] ${e.message}`).join('\n  ');
            throw new Error(`Stack validation failed with the following errors:\n  ${errorList}`);
        }
        const account = stack.env.account || 'unknown-account';
        const region = stack.env.region || 'unknown-region';
        const environment = {
            name: `${account}/${region}`,
            account,
            region
        };
        const missing = Object.keys(stack.missingContext).length ? stack.missingContext : undefined;
        return {
            name: stack.id,
            environment,
            missing,
            template: stack.toCloudFormation(),
            metadata: this.collectMetadata(stack)
        };
    }
    /**
     * Synthesizes multiple stacks
     */
    synthesizeStacks(stackNames) {
        const ret = [];
        for (const stackName of stackNames) {
            ret.push(this.synthesizeStack(stackName));
        }
        return ret;
    }
    /**
     * Returns metadata for all constructs in the stack.
     */
    collectMetadata(stack) {
        const output = {};
        visit(stack);
        // add app-level metadata under "."
        if (this.metadata.length > 0) {
            output[construct_1.PATH_SEP] = this.metadata;
        }
        return output;
        function visit(node) {
            if (node.metadata.length > 0) {
                // Make the path absolute
                output[construct_1.PATH_SEP + node.path] = node.metadata.map(md => tokens_1.resolve(md));
            }
            for (const child of node.children) {
                visit(child);
            }
        }
    }
    collectRuntimeInformation() {
        const libraries = {};
        for (const fileName of Object.keys(require.cache)) {
            const pkg = findNpmPackage(fileName);
            if (pkg && !pkg.private) {
                libraries[pkg.name] = pkg.version;
            }
        }
        // include only libraries that are in the @aws-cdk npm scope
        for (const name of Object.keys(libraries)) {
            if (!name.startsWith('@aws-cdk/')) {
                delete libraries[name];
            }
        }
        // add jsii runtime version
        libraries['jsii-runtime'] = getJsiiAgentVersion();
        return { libraries };
    }
    getStack(stackname) {
        if (stackname == null) {
            throw new Error('Stack name must be defined');
        }
        const stack = this.stacks[stackname];
        if (!stack) {
            throw new Error(`Cannot find stack ${stackname}`);
        }
        return stack;
    }
    loadContext() {
        const contextJson = process.env[cxapi.CONTEXT_ENV];
        const context = !contextJson ? {} : JSON.parse(contextJson);
        for (const key of Object.keys(context)) {
            this.setContext(key, context[key]);
        }
    }
}
exports.App = App;
/**
 * Determines which NPM module a given loaded javascript file is from.
 *
 * The only infromation that is available locally is a list of Javascript files,
 * and every source file is associated with a search path to resolve the further
 * ``require`` calls made from there, which includes its own directory on disk,
 * and parent directories - for example:
 *
 * [ '...repo/packages/aws-cdk-resources/lib/cfn/node_modules',
 *   '...repo/packages/aws-cdk-resources/lib/node_modules',
 *   '...repo/packages/aws-cdk-resources/node_modules',
 *   '...repo/packages/node_modules',
 *   // etc...
 * ]
 *
 * We are looking for ``package.json`` that is anywhere in the tree, except it's
 * in the parent directory, not in the ``node_modules`` directory. For this
 * reason, we strip the ``/node_modules`` suffix off each path and use regular
 * module resolution to obtain a reference to ``package.json``.
 *
 * @param fileName a javascript file name.
 * @returns the NPM module infos (aka ``package.json`` contents), or
 *      ``undefined`` if the lookup was unsuccessful.
 */
function findNpmPackage(fileName) {
    const mod = require.cache[fileName];
    const paths = mod.paths.map(stripNodeModules);
    try {
        const packagePath = require.resolve('package.json', { paths });
        return require(packagePath);
    }
    catch (e) {
        return undefined;
    }
    /**
     * @param s a path.
     * @returns ``s`` with any terminating ``/node_modules``
     *      (or ``\\node_modules``) stripped off.)
     */
    function stripNodeModules(s) {
        if (s.endsWith('/node_modules') || s.endsWith('\\node_modules')) {
            // /node_modules is 13 characters
            return s.substr(0, s.length - 13);
        }
        return s;
    }
}
function getJsiiAgentVersion() {
    let jsiiAgent = process.env.JSII_AGENT;
    // if JSII_AGENT is not specified, we will assume this is a node.js runtime
    // and plug in our node.js version
    if (!jsiiAgent) {
        jsiiAgent = `node.js/${process.version}`;
    }
    return jsiiAgent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLHlCQUEwQjtBQUMxQiw2QkFBOEI7QUFDOUIsa0RBQStDO0FBQy9DLGdEQUE0RTtBQUM1RSwwQ0FBd0M7QUFFeEM7O0dBRUc7QUFDSCxNQUFhLEdBQUksU0FBUSxnQkFBSTtJQUMzQjs7O09BR0c7SUFDSDtRQUNFLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFZLE1BQU07UUFDaEIsTUFBTSxHQUFHLEdBQThCLEVBQUcsQ0FBQztRQUMzQyxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakMsSUFBSSxDQUFDLGFBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsYUFBYSxLQUFLLENBQUMsUUFBUSxFQUFFLHlCQUF5QixDQUFDLENBQUM7YUFDekU7WUFFRCxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQWMsQ0FBQztTQUNoQztRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksR0FBRztRQUNSLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsS0FBSyxDQUFDLFVBQVUsb0JBQW9CLENBQUMsQ0FBQztZQUMvRixPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxtRkFBbUYsQ0FBQyxDQUFDO1lBQzFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEIsT0FBTztTQUNSO1FBRUQsTUFBTSxNQUFN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QUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQy9ELGlDQUFpQztZQUNqQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7U0FDbkM7UUFDRCxPQUFPLENBQUMsQ0FBQztJQUNYLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxtQkFBbUI7SUFDMUIsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFFdkMsMkVBQTJFO0lBQzNFLGtDQUFrQztJQUNsQyxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2QsU0FBUyxHQUFHLFdBQVcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQzFDO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uL3N0YWNrJztcbmltcG9ydCB7IENvbnN0cnVjdCwgTWV0YWRhdGFFbnRyeSwgUEFUSF9TRVAsIFJvb3QgfSBmcm9tICcuL2NvcmUvY29uc3RydWN0JztcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tICcuL2NvcmUvdG9rZW5zJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQ0RLIHByb2dyYW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBBcHAgZXh0ZW5kcyBSb290IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgQ0RLIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0gcmVxdWVzdCBPcHRpb25hbCB0b29sa2l0IHJlcXVlc3QgKGUuZy4gZm9yIHRlc3RzKVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvYWRDb250ZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBzdGFja3MoKSB7XG4gICAgY29uc3Qgb3V0OiB7IFtuYW1lOiBzdHJpbmddOiBTdGFjayB9ID0geyB9O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgaWYgKCFTdGFjay5pc1N0YWNrKGNoaWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjaGlsZCAke2NoaWxkLnRvU3RyaW5nKCl9IG9mIEFwcCBtdXN0IGJlIGEgU3RhY2tgKTtcbiAgICAgIH1cblxuICAgICAgb3V0W2NoaWxkLmlkXSA9IGNoaWxkIGFzIFN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIHByb2dyYW0uIE91dHB1dCBpcyB3cml0dGVuIHRvIG91dHB1dCBkaXJlY3RvcnkgYXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgcHVibGljIHJ1bigpOiB2b2lkIHtcbiAgICBjb25zdCBvdXRkaXIgPSBwcm9jZXNzLmVudltjeGFwaS5PVVRESVJfRU5WXTtcbiAgICBpZiAoIW91dGRpcikge1xuICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYEVSUk9SOiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgXCIke2N4YXBpLk9VVERJUl9FTlZ9XCIgaXMgbm90IGRlZmluZWRcXG5gKTtcbiAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKCdBV1MgQ0RLIFRvb2xraXQgKD49IDAuMTEuMCkgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGlzIHByb2dyYW0uXFxuJyk7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0OiBjeGFwaS5TeW50aGVzaXplUmVzcG9uc2UgPSB7XG4gICAgICB2ZXJzaW9uOiBjeGFwaS5QUk9UT19SRVNQT05TRV9WRVJTSU9OLFxuICAgICAgc3RhY2tzOiB0aGlzLnN5bnRoZXNpemVTdGFja3MoT2JqZWN0LmtleXModGhpcy5zdGFja3MpKSxcbiAgICAgIHJ1bnRpbWU6IHRoaXMuY29sbGVjdFJ1bnRpbWVJbmZvcm1hdGlvbigpXG4gICAgfTtcblxuICAgIGNvbnN0IG91dGZpbGUgPSBwYXRoLmpvaW4ob3V0ZGlyLCBjeGFwaS5PVVRGSUxFX05BTUUpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0ZmlsZSwgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCB1bmRlZmluZWQsIDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGFuZCB2YWxpZGF0ZSBhIHNpbmdsZSBzdGFja1xuICAgKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byBzeW50aGVzaXplXG4gICAqL1xuICBwdWJsaWMgc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZTogc3RyaW5nKTogY3hhcGkuU3ludGhlc2l6ZWRTdGFjayB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKHN0YWNrTmFtZSk7XG5cbiAgICAvLyBmaXJzdCwgdmFsaWRhdGUgdGhpcyBzdGFjayBhbmQgc3RvcCBpZiB0aGVyZSBhcmUgZXJyb3JzLlxuICAgIGNvbnN0IGVycm9ycyA9IHN0YWNrLnZhbGlkYXRlVHJlZSgpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZXJyb3JMaXN0ID0gZXJyb3JzLm1hcChlID0+IGBbJHtlLnNvdXJjZS5wYXRofV0gJHtlLm1lc3NhZ2V9YCkuam9pbignXFxuICAnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhY2sgdmFsaWRhdGlvbiBmYWlsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gICR7ZXJyb3JMaXN0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnQgPSBzdGFjay5lbnYuYWNjb3VudCB8fCAndW5rbm93bi1hY2NvdW50JztcbiAgICBjb25zdCByZWdpb24gPSBzdGFjay5lbnYucmVnaW9uIHx8ICd1bmtub3duLXJlZ2lvbic7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQgPSB7XG4gICAgICBuYW1lOiBgJHthY2NvdW50fS8ke3JlZ2lvbn1gLFxuICAgICAgYWNjb3VudCxcbiAgICAgIHJlZ2lvblxuICAgIH07XG5cbiAgICBjb25zdCBtaXNzaW5nID0gT2JqZWN0LmtleXMoc3RhY2subWlzc2luZ0NvbnRleHQpLmxlbmd0aCA/IHN0YWNrLm1pc3NpbmdDb250ZXh0IDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBzdGFjay5pZCxcbiAgICAgIGVudmlyb25tZW50LFxuICAgICAgbWlzc2luZyxcbiAgICAgIHRlbXBsYXRlOiBzdGFjay50b0Nsb3VkRm9ybWF0aW9uKCksXG4gICAgICBtZXRhZGF0YTogdGhpcy5jb2xsZWN0TWV0YWRhdGEoc3RhY2spXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplcyBtdWx0aXBsZSBzdGFja3NcbiAgICovXG4gIHB1YmxpYyBzeW50aGVzaXplU3RhY2tzKHN0YWNrTmFtZXM6IHN0cmluZ1tdKTogY3hhcGkuU3ludGhlc2l6ZWRTdGFja1tdIHtcbiAgICBjb25zdCByZXQ6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2tbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3RhY2tOYW1lIG9mIHN0YWNrTmFtZXMpIHtcbiAgICAgIHJldC5wdXNoKHRoaXMuc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWV0YWRhdGEgZm9yIGFsbCBjb25zdHJ1Y3RzIGluIHRoZSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBjb2xsZWN0TWV0YWRhdGEoc3RhY2s6IFN0YWNrKSB7XG4gICAgY29uc3Qgb3V0cHV0OiB7IFtpZDogc3RyaW5nXTogTWV0YWRhdGFFbnRyeVtdIH0gPSB7IH07XG5cbiAgICB2aXNpdChzdGFjayk7XG5cbiAgICAvLyBhZGQgYXBwLWxldmVsIG1ldGFkYXRhIHVuZGVyIFwiLlwiXG4gICAgaWYgKHRoaXMubWV0YWRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgb3V0cHV0W1BBVEhfU0VQXSA9IHRoaXMubWV0YWRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcblxuICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGU6IENvbnN0cnVjdCkge1xuICAgICAgaWYgKG5vZGUubWV0YWRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBNYWtlIHRoZSBwYXRoIGFic29sdXRlXG4gICAgICAgIG91dHB1dFtQQVRIX1NFUCArIG5vZGUucGF0aF0gPSBub2RlLm1ldGFkYXRhLm1hcChtZCA9PiByZXNvbHZlKG1kKSBhcyBNZXRhZGF0YUVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbGxlY3RSdW50aW1lSW5mb3JtYXRpb24oKTogY3hhcGkuQXBwUnVudGltZSB7XG4gICAgY29uc3QgbGlicmFyaWVzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBPYmplY3Qua2V5cyhyZXF1aXJlLmNhY2hlKSkge1xuICAgICAgY29uc3QgcGtnID0gZmluZE5wbVBhY2thZ2UoZmlsZU5hbWUpO1xuICAgICAgaWYgKHBrZyAmJiAhcGtnLnByaXZhdGUpIHtcbiAgICAgICAgbGlicmFyaWVzW3BrZy5uYW1lXSA9IHBrZy52ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgb25seSBsaWJyYXJpZXMgdGhhdCBhcmUgaW4gdGhlIEBhd3MtY2RrIG5wbSBzY29wZVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhsaWJyYXJpZXMpKSB7XG4gICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgnQGF3cy1jZGsvJykpIHtcbiAgICAgICAgZGVsZXRlIGxpYnJhcmllc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQganNpaSBydW50aW1lIHZlcnNpb25cbiAgICBsaWJyYXJpZXNbJ2pzaWktcnVudGltZSddID0gZ2V0SnNpaUFnZW50VmVyc2lvbigpO1xuXG4gICAgcmV0dXJuIHsgbGlicmFyaWVzIH07XG4gIH1cblxuICBwcml2YXRlIGdldFN0YWNrKHN0YWNrbmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHN0YWNrbmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWNrIG5hbWUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YWNrc1tzdGFja25hbWVdO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgc3RhY2sgJHtzdGFja25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbiAgfVxuXG4gIHByaXZhdGUgbG9hZENvbnRleHQoKSB7XG4gICAgY29uc3QgY29udGV4dEpzb24gPSBwcm9jZXNzLmVudltjeGFwaS5DT05URVhUX0VOVl07XG4gICAgY29uc3QgY29udGV4dCA9ICFjb250ZXh0SnNvbiA/IHsgfSA6IEpTT04ucGFyc2UoY29udGV4dEpzb24pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbnRleHQpKSB7XG4gICAgICB0aGlzLnNldENvbnRleHQoa2V5LCBjb250ZXh0W2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggTlBNIG1vZHVsZSBhIGdpdmVuIGxvYWRlZCBqYXZhc2NyaXB0IGZpbGUgaXMgZnJvbS5cbiAqXG4gKiBUaGUgb25seSBpbmZyb21hdGlvbiB0aGF0IGlzIGF2YWlsYWJsZSBsb2NhbGx5IGlzIGEgbGlzdCBvZiBKYXZhc2NyaXB0IGZpbGVzLFxuICogYW5kIGV2ZXJ5IHNvdXJjZSBmaWxlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHNlYXJjaCBwYXRoIHRvIHJlc29sdmUgdGhlIGZ1cnRoZXJcbiAqIGBgcmVxdWlyZWBgIGNhbGxzIG1hZGUgZnJvbSB0aGVyZSwgd2hpY2ggaW5jbHVkZXMgaXRzIG93biBkaXJlY3Rvcnkgb24gZGlzayxcbiAqIGFuZCBwYXJlbnQgZGlyZWN0b3JpZXMgLSBmb3IgZXhhbXBsZTpcbiAqXG4gKiBbICcuLi5yZXBvL3BhY2thZ2VzL2F3cy1jZGstcmVzb3VyY2VzL2xpYi9jZm4vbm9kZV9tb2R1bGVzJyxcbiAqICAgJy4uLnJlcG8vcGFja2FnZXMvYXdzLWNkay1yZXNvdXJjZXMvbGliL25vZGVfbW9kdWxlcycsXG4gKiAgICcuLi5yZXBvL3BhY2thZ2VzL2F3cy1jZGstcmVzb3VyY2VzL25vZGVfbW9kdWxlcycsXG4gKiAgICcuLi5yZXBvL3BhY2thZ2VzL25vZGVfbW9kdWxlcycsXG4gKiAgIC8vIGV0Yy4uLlxuICogXVxuICpcbiAqIFdlIGFyZSBsb29raW5nIGZvciBgYHBhY2thZ2UuanNvbmBgIHRoYXQgaXMgYW55d2hlcmUgaW4gdGhlIHRyZWUsIGV4Y2VwdCBpdCdzXG4gKiBpbiB0aGUgcGFyZW50IGRpcmVjdG9yeSwgbm90IGluIHRoZSBgYG5vZGVfbW9kdWxlc2BgIGRpcmVjdG9yeS4gRm9yIHRoaXNcbiAqIHJlYXNvbiwgd2Ugc3RyaXAgdGhlIGBgL25vZGVfbW9kdWxlc2BgIHN1ZmZpeCBvZmYgZWFjaCBwYXRoIGFuZCB1c2UgcmVndWxhclxuICogbW9kdWxlIHJlc29sdXRpb24gdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIGBgcGFja2FnZS5qc29uYGAuXG4gKlxuICogQHBhcmFtIGZpbGVOYW1lIGEgamF2YXNjcmlwdCBmaWxlIG5hbWUuXG4gKiBAcmV0dXJucyB0aGUgTlBNIG1vZHVsZSBpbmZvcyAoYWthIGBgcGFja2FnZS5qc29uYGAgY29udGVudHMpLCBvclxuICogICAgICBgYHVuZGVmaW5lZGBgIGlmIHRoZSBsb29rdXAgd2FzIHVuc3VjY2Vzc2Z1bC5cbiAqL1xuZnVuY3Rpb24gZmluZE5wbVBhY2thZ2UoZmlsZU5hbWU6IHN0cmluZyk6IHsgbmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIHByaXZhdGU/OiBib29sZWFuIH0gfCB1bmRlZmluZWQge1xuICBjb25zdCBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVOYW1lXTtcbiAgY29uc3QgcGF0aHMgPSBtb2QucGF0aHMubWFwKHN0cmlwTm9kZU1vZHVsZXMpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcGFja2FnZVBhdGggPSByZXF1aXJlLnJlc29sdmUoJ3BhY2thZ2UuanNvbicsIHsgcGF0aHMgfSk7XG4gICAgcmV0dXJuIHJlcXVpcmUocGFja2FnZVBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcyBhIHBhdGguXG4gICAqIEByZXR1cm5zIGBgc2BgIHdpdGggYW55IHRlcm1pbmF0aW5nIGBgL25vZGVfbW9kdWxlc2BgXG4gICAqICAgICAgKG9yIGBgXFxcXG5vZGVfbW9kdWxlc2BgKSBzdHJpcHBlZCBvZmYuKVxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaXBOb2RlTW9kdWxlcyhzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChzLmVuZHNXaXRoKCcvbm9kZV9tb2R1bGVzJykgfHwgcy5lbmRzV2l0aCgnXFxcXG5vZGVfbW9kdWxlcycpKSB7XG4gICAgICAvLyAvbm9kZV9tb2R1bGVzIGlzIDEzIGNoYXJhY3RlcnNcbiAgICAgIHJldHVybiBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIDEzKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SnNpaUFnZW50VmVyc2lvbigpIHtcbiAgbGV0IGpzaWlBZ2VudCA9IHByb2Nlc3MuZW52LkpTSUlfQUdFTlQ7XG5cbiAgLy8gaWYgSlNJSV9BR0VOVCBpcyBub3Qgc3BlY2lmaWVkLCB3ZSB3aWxsIGFzc3VtZSB0aGlzIGlzIGEgbm9kZS5qcyBydW50aW1lXG4gIC8vIGFuZCBwbHVnIGluIG91ciBub2RlLmpzIHZlcnNpb25cbiAgaWYgKCFqc2lpQWdlbnQpIHtcbiAgICBqc2lpQWdlbnQgPSBgbm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbn1gO1xuICB9XG5cbiAgcmV0dXJuIGpzaWlBZ2VudDtcbn0iXX0=