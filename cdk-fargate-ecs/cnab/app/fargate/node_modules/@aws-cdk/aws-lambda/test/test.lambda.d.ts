import { Test } from 'nodeunit';
declare const _default: {
    'default function'(test: Test): void;
    'adds policy permissions'(test: Test): void;
    'fails if inline code is used for an invalid runtime'(test: Test): void;
    'addToResourcePolicy': {
        'can be used to add permissions to the Lambda function'(test: Test): void;
        'fails if the principal is not a service or account principals'(test: Test): void;
        'BYORole'(test: Test): void;
    };
    'import/export': {
        'lambda.export() can be used to add Outputs to the stack and returns a LambdaRef object'(test: Test): void;
    };
    'Lambda can serve as EventRule target, permission gets added'(test: Test): void;
    'Lambda code can be read from a local directory via an asset'(test: Test): void;
    'default function with SQS DLQ when client sets deadLetterQueueEnabled to true and functionName defined by client'(test: Test): void;
    'default function with SQS DLQ when client sets deadLetterQueueEnabled to true and functionName not defined by client'(test: Test): void;
    'default function with SQS DLQ when client sets deadLetterQueueEnabled to false'(test: Test): void;
    'default function with SQS DLQ when client provides Queue to be used as DLQ'(test: Test): void;
    'default function with SQS DLQ when client provides Queue to be used as DLQ and deadLetterQueueEnabled set to true'(test: Test): void;
    'error when default function with SQS DLQ when client provides Queue to be used as DLQ and deadLetterQueueEnabled set to false'(test: Test): void;
    'default function with Active tracing'(test: Test): void;
    'default function with PassThrough tracing'(test: Test): void;
    'default function with Disabled tracing'(test: Test): void;
    'grantInvoke adds iam:InvokeFunction'(test: Test): void;
    'addEventSource calls bind'(test: Test): void;
    'support inline code for Ruby runtime'(test: Test): void;
};
export = _default;
