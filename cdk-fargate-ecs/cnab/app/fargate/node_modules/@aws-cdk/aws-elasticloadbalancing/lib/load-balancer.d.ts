import codedeploy = require('@aws-cdk/aws-codedeploy-api');
import { Connections, IConnectable, IPortRange, SecurityGroupRef, VpcNetworkRef } from '@aws-cdk/aws-ec2';
import cdk = require('@aws-cdk/cdk');
/**
 * Construction properties for a LoadBalancer
 */
export interface LoadBalancerProps {
    /**
     * VPC network of the fleet instances
     */
    vpc: VpcNetworkRef;
    /**
     * Whether this is an internet-facing Load Balancer
     *
     * This controls whether the LB has a public IP address assigned. It does
     * not open up the Load Balancer's security groups to public internet access.
     *
     * @default false
     */
    internetFacing?: boolean;
    /**
     * What listeners to set up for the load balancer.
     *
     * Can also be added by .addListener()
     */
    listeners?: LoadBalancerListener[];
    /**
     * What targets to load balance to.
     *
     * Can also be added by .addTarget()
     */
    targets?: ILoadBalancerTarget[];
    /**
     * Health check settings for the load balancing targets.
     *
     * Not required but recommended.
     */
    healthCheck?: HealthCheck;
}
/**
 * Describe the health check to a load balancer
 */
export interface HealthCheck {
    /**
     * What port number to health check on
     */
    port: number;
    /**
     * What protocol to use for health checking
     *
     * The protocol is automatically determined from the port if it's not supplied.
     *
     * @default Automatic
     */
    protocol?: LoadBalancingProtocol;
    /**
     * What path to use for HTTP or HTTPS health check (must return 200)
     *
     * For SSL and TCP health checks, accepting connections is enough to be considered
     * healthy.
     *
     * @default "/"
     */
    path?: string;
    /**
     * After how many successful checks is an instance considered healthy
     *
     * @default 2
     */
    healthyThreshold?: number;
    /**
     * After how many unsuccessful checks is an instance considered unhealthy
     *
     * @default 5
     */
    unhealthyThreshold?: number;
    /**
     * Number of seconds between health checks
     *
     * @default 30
     */
    interval?: number;
    /**
     * Health check timeout
     *
     * @default 5
     */
    timeout?: number;
}
/**
 * Interface that is going to be implemented by constructs that you can load balance to
 */
export interface ILoadBalancerTarget extends IConnectable {
    /**
     * Attach load-balanced target to a classic ELB
     */
    attachToClassicLB(loadBalancer: LoadBalancer): void;
}
/**
 * Add a backend to the load balancer
 */
export interface LoadBalancerListener {
    /**
     * External listening port
     */
    externalPort: number;
    /**
     * What public protocol to use for load balancing
     *
     * Either 'tcp', 'ssl', 'http' or 'https'.
     *
     * May be omitted if the external port is either 80 or 443.
     */
    externalProtocol?: LoadBalancingProtocol;
    /**
     * Instance listening port
     *
     * Same as the externalPort if not specified.
     *
     * @default externalPort
     */
    internalPort?: number;
    /**
     * What public protocol to use for load balancing
     *
     * Either 'tcp', 'ssl', 'http' or 'https'.
     *
     * May be omitted if the internal port is either 80 or 443.
     *
     * The instance protocol is 'tcp' if the front-end protocol
     * is 'tcp' or 'ssl', the instance protocol is 'http' if the
     * front-end protocol is 'https'.
     */
    internalProtocol?: LoadBalancingProtocol;
    /**
     * SSL policy names
     */
    policyNames?: string[];
    /**
     * ID of SSL certificate
     */
    sslCertificateId?: string;
    /**
     * Allow connections to the load balancer from the given set of connection peers
     *
     * By default, connections will be allowed from anywhere. Set this to an empty list
     * to deny connections, or supply a custom list of peers to allow connections from
     * (IP ranges or security groups).
     *
     * @default Anywhere
     */
    allowConnectionsFrom?: IConnectable[];
}
export declare enum LoadBalancingProtocol {
    Tcp = "tcp",
    Ssl = "ssl",
    Http = "http",
    Https = "https"
}
/**
 * A load balancer with a single listener
 *
 * Routes to a fleet of of instances in a VPC.
 */
export declare class LoadBalancer extends cdk.Construct implements IConnectable, codedeploy.ILoadBalancer {
    /**
     * Control all connections from and to this load balancer
     */
    readonly connections: Connections;
    /**
     * An object controlling specifically the connections for each listener added to this load balancer
     */
    readonly listenerPorts: ListenerPort[];
    private readonly elb;
    private readonly securityGroup;
    private readonly listeners;
    private readonly instancePorts;
    private readonly targets;
    constructor(parent: cdk.Construct, name: string, props: LoadBalancerProps);
    /**
     * Add a backend to the load balancer
     *
     * @returns A ListenerPort object that controls connections to the listener port
     */
    addListener(listener: LoadBalancerListener): ListenerPort;
    addTarget(target: ILoadBalancerTarget): void;
    readonly loadBalancerName: string;
    readonly loadBalancerCanonicalHostedZoneName: string;
    readonly loadBalancerDnsName: string;
    readonly loadBalancerSourceSecurityGroupGroupName: string;
    readonly loadBalancerSourceSecurityGroupOwnerAlias: string;
    asCodeDeployLoadBalancer(): codedeploy.ILoadBalancerProps;
    /**
     * Allow connections to all existing targets on new instance port
     */
    private newInstancePort;
    /**
     * Allow connections to target on all existing instance ports
     */
    private newTarget;
    /**
     * Allow connections for a single (port, target) pair
     */
    private allowTargetConnection;
}
/**
 * Reference to a listener's port just created.
 *
 * This implements IConnectable with a default port (the port that an ELB
 * listener was just created on) for a given security group so that it can be
 * conveniently used just like any Connectable. E.g:
 *
 *    const listener = elb.addListener(...);
 *
 *    listener.connections.allowDefaultPortFromAnyIPv4();
 *    // or
 *    instance.connections.allowToDefaultPort(listener);
 */
export declare class ListenerPort implements IConnectable {
    readonly connections: Connections;
    constructor(securityGroup: SecurityGroupRef, defaultPortRange: IPortRange);
}
