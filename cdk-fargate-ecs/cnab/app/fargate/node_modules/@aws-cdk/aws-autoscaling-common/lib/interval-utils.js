"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Normalize the given interval set to cover the complete number line and make sure it has at most one gap
 */
function normalizeIntervals(intervals, changesAreAbsolute) {
    // Make intervals a complete numberline
    const full = orderAndCompleteIntervals(intervals);
    // Add 'undefined's in uncovered areas of the number line
    makeGapsUndefined(full);
    // In case of relative changes, treat 0-change also as 'undefined' (= no change action)
    if (!changesAreAbsolute) {
        makeZerosUndefined(full);
    }
    // Combine adjacent undefines and make sure there's at most one of them
    combineUndefineds(full);
    validateAtMostOneUndefined(full);
    return full;
}
exports.normalizeIntervals = normalizeIntervals;
/**
 * Completely order scaling intervals, making their lower and upper bounds concrete.
 */
function orderAndCompleteIntervals(intervals) {
    if (intervals.length < 2) {
        throw new Error('Require at least 2 intervals');
    }
    for (const interval of intervals) {
        if (interval.lower === undefined && interval.upper === undefined) {
            throw new Error(`Must supply at least one of 'upper' or 'lower', got: ${JSON.stringify(interval)}`);
        }
    }
    // Make a copy
    intervals = intervals.map(x => (Object.assign({}, x)));
    // Sort by whatever number we have for each interval
    intervals.sort(comparatorFromKey((x) => x.lower !== undefined ? x.lower : x.upper));
    // Propagate boundaries until no more change
    while (propagateBounds(intervals)) { /* Repeat */ }
    // Validate that no intervals have undefined bounds now, which must mean they're complete.
    if (intervals[0].lower === undefined) {
        intervals[0].lower = 0;
    }
    if (last(intervals).upper === undefined) {
        last(intervals).upper = Infinity;
    }
    for (const interval of intervals) {
        if (interval.lower === undefined || interval.upper === undefined) {
            throw new Error(`Could not determine the lower and upper bounds for ${JSON.stringify(interval)}`);
        }
    }
    const completeIntervals = intervals;
    // Validate that we have nonoverlapping intervals now.
    for (let i = 0; i < completeIntervals.length - 1; i++) {
        if (overlap(completeIntervals[i], completeIntervals[i + 1])) {
            throw new Error(`Two intervals overlap: ${JSON.stringify(completeIntervals[i])} and ${JSON.stringify(completeIntervals[i + 1])}`);
        }
    }
    // Fill up the gaps
    return completeIntervals;
}
/**
 * Make the intervals cover the complete number line
 *
 * This entails adding intervals with an 'undefined' change to fill up the gaps.
 *
 * Since metrics have a halfopen interval, the first one will get a lower bound
 * of 0, the last one will get an upper bound of +Infinity.
 *
 * In case of absolute adjustments, the lower number of the adjacent bound will
 * be used, which means conservative change. In case of relative adjustments,
 * we'll use relative adjusment 0 (which means no change).
 */
function makeGapsUndefined(intervals) {
    // Add edge intervals if necessary, but only for relative adjustments. Since we're
    // going to make scaling intervals extend all the way out to infinity on either side,
    // the result is the same for absolute adjustments anyway.
    if (intervals[0].lower !== 0) {
        intervals.splice(0, 1, {
            lower: 0,
            upper: intervals[0].lower,
            change: undefined,
        });
    }
    if (last(intervals).upper !== Infinity) {
        intervals.push({
            lower: last(intervals).upper,
            upper: Infinity,
            change: undefined
        });
    }
    let i = 1;
    while (i < intervals.length) {
        if (intervals[i - 1].upper < intervals[i].lower) {
            intervals.splice(i, 0, {
                lower: intervals[i - 1].upper,
                upper: intervals[i].lower,
                change: undefined
            });
        }
        else {
            i++;
        }
    }
}
/**
 * Turn zero changes into undefined, in-place
 */
function makeZerosUndefined(intervals) {
    for (const interval of intervals) {
        if (interval.change === 0) {
            interval.change = undefined;
        }
    }
}
/**
 * If there are adjacent "undefined" intervals, combine them
 */
function combineUndefineds(intervals) {
    let i = 0;
    while (i < intervals.length - 1) {
        if (intervals[i].change === undefined && intervals[i + 1].change === undefined) {
            intervals[i].upper = intervals[i + 1].upper;
            intervals.splice(i + 1, 1);
        }
        else {
            i++;
        }
    }
}
function validateAtMostOneUndefined(intervals) {
    const undef = intervals.filter(x => x.change === undefined);
    if (undef.length > 1) {
        throw new Error(`Can have at most one no-change interval, got ${JSON.stringify(undef)}`);
    }
}
function comparatorFromKey(keyFn) {
    return (a, b) => {
        const keyA = keyFn(a);
        const keyB = keyFn(b);
        if (keyA < keyB) {
            return -1;
        }
        if (keyA === keyB) {
            return 0;
        }
        return 1;
    };
}
function propagateBounds(intervals) {
    let ret = false;
    // Propagate upper bounds upwards
    for (let i = 0; i < intervals.length - 1; i++) {
        if (intervals[i].upper !== undefined && intervals[i + 1].lower === undefined) {
            intervals[i + 1].lower = intervals[i].upper;
            ret = true;
        }
    }
    // Propagate lower bounds downwards
    for (let i = intervals.length - 1; i >= 1; i--) {
        if (intervals[i].lower !== undefined && intervals[i - 1].upper === undefined) {
            intervals[i - 1].upper = intervals[i].lower;
            ret = true;
        }
    }
    return ret;
}
/**
 * Whether two intervals overlap
 */
function overlap(a, b) {
    return a.lower < b.upper && a.upper > b.lower;
}
function last(xs) {
    return xs[xs.length - 1];
}
/**
 * Locate the intervals that should have the alarm thresholds, by index.
 *
 * Pick the intervals on either side of the singleton "undefined" interval, or
 * pick the middle interval if there's no such interval.
 */
function findAlarmThresholds(intervals) {
    const gapIndex = intervals.findIndex(x => x.change === undefined);
    if (gapIndex !== -1) {
        return {
            lowerAlarmIntervalIndex: gapIndex > 0 ? gapIndex - 1 : undefined,
            upperAlarmIntervalIndex: gapIndex < intervals.length - 1 ? gapIndex + 1 : undefined,
        };
    }
    if (intervals.length === 1) {
        return { upperAlarmIntervalIndex: 0 };
    }
    const middleIndex = Math.floor(intervals.length / 2);
    return {
        lowerAlarmIntervalIndex: middleIndex - 1,
        upperAlarmIntervalIndex: middleIndex
    };
}
exports.findAlarmThresholds = findAlarmThresholds;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJ2YWwtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbnRlcnZhbC11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQVFBOztHQUVHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsU0FBNEIsRUFBRSxrQkFBMkI7SUFDMUYsdUNBQXVDO0lBQ3ZDLE1BQU0sSUFBSSxHQUFHLHlCQUF5QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELHlEQUF5RDtJQUN6RCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV4Qix1RkFBdUY7SUFDdkYsSUFBSSxDQUFDLGtCQUFrQixFQUFFO1FBQUUsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTtJQUV0RCx1RUFBdUU7SUFDdkUsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsMEJBQTBCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFakMsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBZEQsZ0RBY0M7QUFFRDs7R0FFRztBQUNILFNBQVMseUJBQXlCLENBQUMsU0FBNEI7SUFDN0QsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7S0FDakQ7SUFFRCxLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRTtRQUNoQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ2hFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JHO0tBQ0Y7SUFFRCxjQUFjO0lBQ2QsU0FBUyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxtQkFBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRXpDLG9EQUFvRDtJQUNwRCxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBa0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRXJHLDRDQUE0QztJQUM1QyxPQUFPLGVBQWUsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLFlBQVksRUFBRTtJQUVuRCwwRkFBMEY7SUFDMUYsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQUU7SUFDakUsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO0tBQUU7SUFDOUUsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUU7UUFDaEMsSUFBSSxRQUFRLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxRQUFRLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUNoRSxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNuRztLQUNGO0lBRUQsTUFBTSxpQkFBaUIsR0FBRyxTQUFzQyxDQUFDO0lBRWpFLHNEQUFzRDtJQUN0RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNyRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDbkk7S0FDRjtJQUVELG1CQUFtQjtJQUVuQixPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILFNBQVMsaUJBQWlCLENBQUMsU0FBb0M7SUFDN0Qsa0ZBQWtGO0lBQ2xGLHFGQUFxRjtJQUNyRiwwREFBMEQ7SUFDMUQsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtRQUM1QixTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDckIsS0FBSyxFQUFFLENBQUM7WUFDUixLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDekIsTUFBTSxFQUFFLFNBQVM7U0FDbEIsQ0FBQyxDQUFDO0tBQ0o7SUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQ3RDLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDYixLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUs7WUFDNUIsS0FBSyxFQUFFLFFBQVE7WUFDZixNQUFNLEVBQUUsU0FBUztTQUNsQixDQUFDLENBQUM7S0FDSjtJQUVELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUU7UUFDM0IsSUFBSSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFO1lBQy9DLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDckIsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSztnQkFDN0IsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO2dCQUN6QixNQUFNLEVBQUUsU0FBUzthQUNsQixDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsQ0FBQyxFQUFFLENBQUM7U0FDTDtLQUNGO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxTQUFvQztJQUM5RCxLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRTtRQUNoQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLFFBQVEsQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO1NBQzdCO0tBQ0Y7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLGlCQUFpQixDQUFDLFNBQW9DO0lBQzdELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQy9CLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzlFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDNUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzVCO2FBQU07WUFDTCxDQUFDLEVBQUUsQ0FBQztTQUNMO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsU0FBUywwQkFBMEIsQ0FBQyxTQUFvQztJQUN0RSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxTQUFTLENBQUMsQ0FBQztJQUM1RCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzFGO0FBQ0gsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQU8sS0FBa0I7SUFDakQsT0FBTyxDQUFDLENBQUksRUFBRSxDQUFJLEVBQUUsRUFBRTtRQUNwQixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRCLElBQUksSUFBSSxHQUFHLElBQUksRUFBRTtZQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FBRTtRQUMvQixJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7WUFBRSxPQUFPLENBQUMsQ0FBQztTQUFFO1FBQ2hDLE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLFNBQTRCO0lBQ25ELElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQztJQUVoQixpQ0FBaUM7SUFDakMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzdDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQzVFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDNUMsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNaO0tBQ0Y7SUFFRCxtQ0FBbUM7SUFDbkMsS0FBSyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzlDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQzVFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDNUMsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNaO0tBQ0Y7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsT0FBTyxDQUFDLENBQTBCLEVBQUUsQ0FBMEI7SUFDckUsT0FBTyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ2hELENBQUM7QUFFRCxTQUFTLElBQUksQ0FBSSxFQUFPO0lBQ3RCLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQU9EOzs7OztHQUtHO0FBQ0gsU0FBZ0IsbUJBQW1CLENBQUMsU0FBb0M7SUFDdEUsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDLENBQUM7SUFFbEUsSUFBSSxRQUFRLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDbkIsT0FBTztZQUNMLHVCQUF1QixFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVM7WUFDaEUsdUJBQXVCLEVBQUUsUUFBUSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO1NBQ3BGLENBQUM7S0FDSDtJQUVELElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDMUIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLENBQUMsRUFBRSxDQUFDO0tBQ3ZDO0lBRUQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRXJELE9BQU87UUFDTCx1QkFBdUIsRUFBRSxXQUFXLEdBQUcsQ0FBQztRQUN4Qyx1QkFBdUIsRUFBRSxXQUFXO0tBQ3JDLENBQUM7QUFDSixDQUFDO0FBcEJELGtEQW9CQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjYWxpbmdJbnRlcnZhbCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGVTY2FsaW5nSW50ZXJ2YWwge1xuICBsb3dlcjogbnVtYmVyO1xuICB1cHBlcjogbnVtYmVyO1xuICBjaGFuZ2U/OiBudW1iZXI7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBpbnRlcnZhbCBzZXQgdG8gY292ZXIgdGhlIGNvbXBsZXRlIG51bWJlciBsaW5lIGFuZCBtYWtlIHN1cmUgaXQgaGFzIGF0IG1vc3Qgb25lIGdhcFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSW50ZXJ2YWxzKGludGVydmFsczogU2NhbGluZ0ludGVydmFsW10sIGNoYW5nZXNBcmVBYnNvbHV0ZTogYm9vbGVhbik6IENvbXBsZXRlU2NhbGluZ0ludGVydmFsW10ge1xuICAvLyBNYWtlIGludGVydmFscyBhIGNvbXBsZXRlIG51bWJlcmxpbmVcbiAgY29uc3QgZnVsbCA9IG9yZGVyQW5kQ29tcGxldGVJbnRlcnZhbHMoaW50ZXJ2YWxzKTtcbiAgLy8gQWRkICd1bmRlZmluZWQncyBpbiB1bmNvdmVyZWQgYXJlYXMgb2YgdGhlIG51bWJlciBsaW5lXG4gIG1ha2VHYXBzVW5kZWZpbmVkKGZ1bGwpO1xuXG4gIC8vIEluIGNhc2Ugb2YgcmVsYXRpdmUgY2hhbmdlcywgdHJlYXQgMC1jaGFuZ2UgYWxzbyBhcyAndW5kZWZpbmVkJyAoPSBubyBjaGFuZ2UgYWN0aW9uKVxuICBpZiAoIWNoYW5nZXNBcmVBYnNvbHV0ZSkgeyBtYWtlWmVyb3NVbmRlZmluZWQoZnVsbCk7IH1cblxuICAvLyBDb21iaW5lIGFkamFjZW50IHVuZGVmaW5lcyBhbmQgbWFrZSBzdXJlIHRoZXJlJ3MgYXQgbW9zdCBvbmUgb2YgdGhlbVxuICBjb21iaW5lVW5kZWZpbmVkcyhmdWxsKTtcbiAgdmFsaWRhdGVBdE1vc3RPbmVVbmRlZmluZWQoZnVsbCk7XG5cbiAgcmV0dXJuIGZ1bGw7XG59XG5cbi8qKlxuICogQ29tcGxldGVseSBvcmRlciBzY2FsaW5nIGludGVydmFscywgbWFraW5nIHRoZWlyIGxvd2VyIGFuZCB1cHBlciBib3VuZHMgY29uY3JldGUuXG4gKi9cbmZ1bmN0aW9uIG9yZGVyQW5kQ29tcGxldGVJbnRlcnZhbHMoaW50ZXJ2YWxzOiBTY2FsaW5nSW50ZXJ2YWxbXSk6IENvbXBsZXRlU2NhbGluZ0ludGVydmFsW10ge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmUgYXQgbGVhc3QgMiBpbnRlcnZhbHMnKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgaW50ZXJ2YWxzKSB7XG4gICAgaWYgKGludGVydmFsLmxvd2VyID09PSB1bmRlZmluZWQgJiYgaW50ZXJ2YWwudXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IHN1cHBseSBhdCBsZWFzdCBvbmUgb2YgJ3VwcGVyJyBvciAnbG93ZXInLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoaW50ZXJ2YWwpfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ha2UgYSBjb3B5XG4gIGludGVydmFscyA9IGludGVydmFscy5tYXAoeCA9PiAoey4uLnh9KSk7XG5cbiAgLy8gU29ydCBieSB3aGF0ZXZlciBudW1iZXIgd2UgaGF2ZSBmb3IgZWFjaCBpbnRlcnZhbFxuICBpbnRlcnZhbHMuc29ydChjb21wYXJhdG9yRnJvbUtleSgoeDogU2NhbGluZ0ludGVydmFsKSA9PiB4Lmxvd2VyICE9PSB1bmRlZmluZWQgPyB4Lmxvd2VyIDogeC51cHBlcikpO1xuXG4gIC8vIFByb3BhZ2F0ZSBib3VuZGFyaWVzIHVudGlsIG5vIG1vcmUgY2hhbmdlXG4gIHdoaWxlIChwcm9wYWdhdGVCb3VuZHMoaW50ZXJ2YWxzKSkgeyAvKiBSZXBlYXQgKi8gfVxuXG4gIC8vIFZhbGlkYXRlIHRoYXQgbm8gaW50ZXJ2YWxzIGhhdmUgdW5kZWZpbmVkIGJvdW5kcyBub3csIHdoaWNoIG11c3QgbWVhbiB0aGV5J3JlIGNvbXBsZXRlLlxuICBpZiAoaW50ZXJ2YWxzWzBdLmxvd2VyID09PSB1bmRlZmluZWQpIHsgaW50ZXJ2YWxzWzBdLmxvd2VyID0gMDsgfVxuICBpZiAobGFzdChpbnRlcnZhbHMpLnVwcGVyID09PSB1bmRlZmluZWQpIHsgbGFzdChpbnRlcnZhbHMpLnVwcGVyID0gSW5maW5pdHk7IH1cbiAgZm9yIChjb25zdCBpbnRlcnZhbCBvZiBpbnRlcnZhbHMpIHtcbiAgICBpZiAoaW50ZXJ2YWwubG93ZXIgPT09IHVuZGVmaW5lZCB8fCBpbnRlcnZhbC51cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZHMgZm9yICR7SlNPTi5zdHJpbmdpZnkoaW50ZXJ2YWwpfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbXBsZXRlSW50ZXJ2YWxzID0gaW50ZXJ2YWxzIGFzIENvbXBsZXRlU2NhbGluZ0ludGVydmFsW107XG5cbiAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBoYXZlIG5vbm92ZXJsYXBwaW5nIGludGVydmFscyBub3cuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcGxldGVJbnRlcnZhbHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG92ZXJsYXAoY29tcGxldGVJbnRlcnZhbHNbaV0sIGNvbXBsZXRlSW50ZXJ2YWxzW2kgKyAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHdvIGludGVydmFscyBvdmVybGFwOiAke0pTT04uc3RyaW5naWZ5KGNvbXBsZXRlSW50ZXJ2YWxzW2ldKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkoY29tcGxldGVJbnRlcnZhbHNbaSArIDFdKX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaWxsIHVwIHRoZSBnYXBzXG5cbiAgcmV0dXJuIGNvbXBsZXRlSW50ZXJ2YWxzO1xufVxuXG4vKipcbiAqIE1ha2UgdGhlIGludGVydmFscyBjb3ZlciB0aGUgY29tcGxldGUgbnVtYmVyIGxpbmVcbiAqXG4gKiBUaGlzIGVudGFpbHMgYWRkaW5nIGludGVydmFscyB3aXRoIGFuICd1bmRlZmluZWQnIGNoYW5nZSB0byBmaWxsIHVwIHRoZSBnYXBzLlxuICpcbiAqIFNpbmNlIG1ldHJpY3MgaGF2ZSBhIGhhbGZvcGVuIGludGVydmFsLCB0aGUgZmlyc3Qgb25lIHdpbGwgZ2V0IGEgbG93ZXIgYm91bmRcbiAqIG9mIDAsIHRoZSBsYXN0IG9uZSB3aWxsIGdldCBhbiB1cHBlciBib3VuZCBvZiArSW5maW5pdHkuXG4gKlxuICogSW4gY2FzZSBvZiBhYnNvbHV0ZSBhZGp1c3RtZW50cywgdGhlIGxvd2VyIG51bWJlciBvZiB0aGUgYWRqYWNlbnQgYm91bmQgd2lsbFxuICogYmUgdXNlZCwgd2hpY2ggbWVhbnMgY29uc2VydmF0aXZlIGNoYW5nZS4gSW4gY2FzZSBvZiByZWxhdGl2ZSBhZGp1c3RtZW50cyxcbiAqIHdlJ2xsIHVzZSByZWxhdGl2ZSBhZGp1c21lbnQgMCAod2hpY2ggbWVhbnMgbm8gY2hhbmdlKS5cbiAqL1xuZnVuY3Rpb24gbWFrZUdhcHNVbmRlZmluZWQoaW50ZXJ2YWxzOiBDb21wbGV0ZVNjYWxpbmdJbnRlcnZhbFtdKSB7XG4gIC8vIEFkZCBlZGdlIGludGVydmFscyBpZiBuZWNlc3NhcnksIGJ1dCBvbmx5IGZvciByZWxhdGl2ZSBhZGp1c3RtZW50cy4gU2luY2Ugd2UncmVcbiAgLy8gZ29pbmcgdG8gbWFrZSBzY2FsaW5nIGludGVydmFscyBleHRlbmQgYWxsIHRoZSB3YXkgb3V0IHRvIGluZmluaXR5IG9uIGVpdGhlciBzaWRlLFxuICAvLyB0aGUgcmVzdWx0IGlzIHRoZSBzYW1lIGZvciBhYnNvbHV0ZSBhZGp1c3RtZW50cyBhbnl3YXkuXG4gIGlmIChpbnRlcnZhbHNbMF0ubG93ZXIgIT09IDApIHtcbiAgICBpbnRlcnZhbHMuc3BsaWNlKDAsIDEsIHtcbiAgICAgIGxvd2VyOiAwLFxuICAgICAgdXBwZXI6IGludGVydmFsc1swXS5sb3dlcixcbiAgICAgIGNoYW5nZTogdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG4gIGlmIChsYXN0KGludGVydmFscykudXBwZXIgIT09IEluZmluaXR5KSB7XG4gICAgaW50ZXJ2YWxzLnB1c2goe1xuICAgICAgbG93ZXI6IGxhc3QoaW50ZXJ2YWxzKS51cHBlcixcbiAgICAgIHVwcGVyOiBJbmZpbml0eSxcbiAgICAgIGNoYW5nZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cblxuICBsZXQgaSA9IDE7XG4gIHdoaWxlIChpIDwgaW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgIGlmIChpbnRlcnZhbHNbaSAtIDFdLnVwcGVyIDwgaW50ZXJ2YWxzW2ldLmxvd2VyKSB7XG4gICAgICBpbnRlcnZhbHMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgbG93ZXI6IGludGVydmFsc1tpIC0gMV0udXBwZXIsXG4gICAgICAgIHVwcGVyOiBpbnRlcnZhbHNbaV0ubG93ZXIsXG4gICAgICAgIGNoYW5nZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFR1cm4gemVybyBjaGFuZ2VzIGludG8gdW5kZWZpbmVkLCBpbi1wbGFjZVxuICovXG5mdW5jdGlvbiBtYWtlWmVyb3NVbmRlZmluZWQoaW50ZXJ2YWxzOiBDb21wbGV0ZVNjYWxpbmdJbnRlcnZhbFtdKSB7XG4gIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgaW50ZXJ2YWxzKSB7XG4gICAgaWYgKGludGVydmFsLmNoYW5nZSA9PT0gMCkge1xuICAgICAgaW50ZXJ2YWwuY2hhbmdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZXJlIGFyZSBhZGphY2VudCBcInVuZGVmaW5lZFwiIGludGVydmFscywgY29tYmluZSB0aGVtXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVVbmRlZmluZWRzKGludGVydmFsczogQ29tcGxldGVTY2FsaW5nSW50ZXJ2YWxbXSkge1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaW50ZXJ2YWxzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoaW50ZXJ2YWxzW2ldLmNoYW5nZSA9PT0gdW5kZWZpbmVkICYmIGludGVydmFsc1tpICsgMV0uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGludGVydmFsc1tpXS51cHBlciA9IGludGVydmFsc1tpICsgMV0udXBwZXI7XG4gICAgICBpbnRlcnZhbHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0TW9zdE9uZVVuZGVmaW5lZChpbnRlcnZhbHM6IENvbXBsZXRlU2NhbGluZ0ludGVydmFsW10pIHtcbiAgY29uc3QgdW5kZWYgPSBpbnRlcnZhbHMuZmlsdGVyKHggPT4geC5jaGFuZ2UgPT09IHVuZGVmaW5lZCk7XG4gIGlmICh1bmRlZi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gaGF2ZSBhdCBtb3N0IG9uZSBuby1jaGFuZ2UgaW50ZXJ2YWwsIGdvdCAke0pTT04uc3RyaW5naWZ5KHVuZGVmKX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJhdG9yRnJvbUtleTxULCBVPihrZXlGbjogKHg6IFQpID0+IFUpIHtcbiAgcmV0dXJuIChhOiBULCBiOiBUKSA9PiB7XG4gICAgY29uc3Qga2V5QSA9IGtleUZuKGEpO1xuICAgIGNvbnN0IGtleUIgPSBrZXlGbihiKTtcblxuICAgIGlmIChrZXlBIDwga2V5QikgeyByZXR1cm4gLTE7IH1cbiAgICBpZiAoa2V5QSA9PT0ga2V5QikgeyByZXR1cm4gMDsgfVxuICAgIHJldHVybiAxO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVCb3VuZHMoaW50ZXJ2YWxzOiBTY2FsaW5nSW50ZXJ2YWxbXSkge1xuICBsZXQgcmV0ID0gZmFsc2U7XG5cbiAgLy8gUHJvcGFnYXRlIHVwcGVyIGJvdW5kcyB1cHdhcmRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJ2YWxzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpbnRlcnZhbHNbaV0udXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpbnRlcnZhbHNbaSArIDFdLmxvd2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGludGVydmFsc1tpICsgMV0ubG93ZXIgPSBpbnRlcnZhbHNbaV0udXBwZXI7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb3BhZ2F0ZSBsb3dlciBib3VuZHMgZG93bndhcmRzXG4gIGZvciAobGV0IGkgPSBpbnRlcnZhbHMubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICBpZiAoaW50ZXJ2YWxzW2ldLmxvd2VyICE9PSB1bmRlZmluZWQgJiYgaW50ZXJ2YWxzW2kgLSAxXS51cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnRlcnZhbHNbaSAtIDFdLnVwcGVyID0gaW50ZXJ2YWxzW2ldLmxvd2VyO1xuICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdHdvIGludGVydmFscyBvdmVybGFwXG4gKi9cbmZ1bmN0aW9uIG92ZXJsYXAoYTogQ29tcGxldGVTY2FsaW5nSW50ZXJ2YWwsIGI6IENvbXBsZXRlU2NhbGluZ0ludGVydmFsKSB7XG4gIHJldHVybiBhLmxvd2VyIDwgYi51cHBlciAmJiBhLnVwcGVyID4gYi5sb3dlcjtcbn1cblxuZnVuY3Rpb24gbGFzdDxUPih4czogVFtdKSB7XG4gIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGFybXMge1xuICBsb3dlckFsYXJtSW50ZXJ2YWxJbmRleD86IG51bWJlcjtcbiAgdXBwZXJBbGFybUludGVydmFsSW5kZXg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogTG9jYXRlIHRoZSBpbnRlcnZhbHMgdGhhdCBzaG91bGQgaGF2ZSB0aGUgYWxhcm0gdGhyZXNob2xkcywgYnkgaW5kZXguXG4gKlxuICogUGljayB0aGUgaW50ZXJ2YWxzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBzaW5nbGV0b24gXCJ1bmRlZmluZWRcIiBpbnRlcnZhbCwgb3JcbiAqIHBpY2sgdGhlIG1pZGRsZSBpbnRlcnZhbCBpZiB0aGVyZSdzIG5vIHN1Y2ggaW50ZXJ2YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWxhcm1UaHJlc2hvbGRzKGludGVydmFsczogQ29tcGxldGVTY2FsaW5nSW50ZXJ2YWxbXSk6IEFsYXJtcyB7XG4gIGNvbnN0IGdhcEluZGV4ID0gaW50ZXJ2YWxzLmZpbmRJbmRleCh4ID0+IHguY2hhbmdlID09PSB1bmRlZmluZWQpO1xuXG4gIGlmIChnYXBJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93ZXJBbGFybUludGVydmFsSW5kZXg6IGdhcEluZGV4ID4gMCA/IGdhcEluZGV4IC0gMSA6IHVuZGVmaW5lZCxcbiAgICAgIHVwcGVyQWxhcm1JbnRlcnZhbEluZGV4OiBnYXBJbmRleCA8IGludGVydmFscy5sZW5ndGggLSAxID8gZ2FwSW5kZXggKyAxIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7IHVwcGVyQWxhcm1JbnRlcnZhbEluZGV4OiAwIH07XG4gIH1cblxuICBjb25zdCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3IoaW50ZXJ2YWxzLmxlbmd0aCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgbG93ZXJBbGFybUludGVydmFsSW5kZXg6IG1pZGRsZUluZGV4IC0gMSxcbiAgICB1cHBlckFsYXJtSW50ZXJ2YWxJbmRleDogbWlkZGxlSW5kZXhcbiAgfTtcbn0iXX0=