"use strict";
const assert_1 = require("@aws-cdk/assert");
const cdk_1 = require("@aws-cdk/cdk");
const lib_1 = require("../lib");
class SomethingConnectable {
    constructor(connections) {
        this.connections = connections;
    }
}
module.exports = {
    'peering between two security groups does not recursive infinitely'(test) {
        // GIVEN
        const stack = new cdk_1.Stack(undefined, 'TestStack', { env: { account: '12345678', region: 'dummy' } });
        const vpc = new lib_1.VpcNetwork(stack, 'VPC');
        const sg1 = new lib_1.SecurityGroup(stack, 'SG1', { vpc });
        const sg2 = new lib_1.SecurityGroup(stack, 'SG2', { vpc });
        const conn1 = new SomethingConnectable(new lib_1.Connections({ securityGroups: [sg1] }));
        const conn2 = new SomethingConnectable(new lib_1.Connections({ securityGroups: [sg2] }));
        // WHEN
        conn1.connections.allowTo(conn2, new lib_1.TcpPort(80), 'Test');
        // THEN -- it finishes!
        test.done();
    },
    '(imported) SecurityGroup can be used as target of .allowTo()'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.VpcNetwork(stack, 'VPC');
        const sg1 = new lib_1.SecurityGroup(stack, 'SomeSecurityGroup', { vpc, allowAllOutbound: false });
        const somethingConnectable = new SomethingConnectable(new lib_1.Connections({ securityGroups: [sg1] }));
        const securityGroup = lib_1.SecurityGroupRef.import(stack, 'ImportedSG', { securityGroupId: 'sg-12345' });
        // WHEN
        somethingConnectable.connections.allowTo(securityGroup, new lib_1.TcpAllPorts(), 'Connect there');
        // THEN: rule to generated security group to connect to imported
        assert_1.expect(stack).to(assert_1.haveResource("AWS::EC2::SecurityGroupEgress", {
            GroupId: { "Fn::GetAtt": ["SomeSecurityGroupEF219AD6", "GroupId"] },
            IpProtocol: "tcp",
            Description: "Connect there",
            DestinationSecurityGroupId: "sg-12345",
            FromPort: 0,
            ToPort: 65535
        }));
        // THEN: rule to imported security group to allow connections from generated
        assert_1.expect(stack).to(assert_1.haveResource("AWS::EC2::SecurityGroupIngress", {
            IpProtocol: "tcp",
            Description: "Connect there",
            FromPort: 0,
            GroupId: "sg-12345",
            SourceSecurityGroupId: { "Fn::GetAtt": ["SomeSecurityGroupEF219AD6", "GroupId"] },
            ToPort: 65535
        }));
        test.done();
    },
    'security groups added to connections after rule still gets rule'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.VpcNetwork(stack, 'VPC');
        const sg1 = new lib_1.SecurityGroup(stack, 'SecurityGroup1', { vpc, allowAllOutbound: false });
        const sg2 = new lib_1.SecurityGroup(stack, 'SecurityGroup2', { vpc, allowAllOutbound: false });
        const connections = new lib_1.Connections({ securityGroups: [sg1] });
        // WHEN
        connections.allowFromAnyIPv4(new lib_1.TcpPort(88));
        connections.addSecurityGroup(sg2);
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            GroupDescription: "SecurityGroup1",
            SecurityGroupIngress: [
                {
                    Description: "from 0.0.0.0/0:88",
                    CidrIp: "0.0.0.0/0",
                    FromPort: 88,
                    ToPort: 88,
                    IpProtocol: 'tcp'
                }
            ]
        }));
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            GroupDescription: "SecurityGroup2",
            SecurityGroupIngress: [
                {
                    Description: "from 0.0.0.0/0:88",
                    CidrIp: "0.0.0.0/0",
                    FromPort: 88,
                    ToPort: 88,
                    IpProtocol: 'tcp'
                }
            ]
        }));
        test.done();
    },
    'when security groups are added to target they also get the rule'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.VpcNetwork(stack, 'VPC');
        const sg1 = new lib_1.SecurityGroup(stack, 'SecurityGroup1', { vpc, allowAllOutbound: false });
        const sg2 = new lib_1.SecurityGroup(stack, 'SecurityGroup2', { vpc, allowAllOutbound: false });
        const sg3 = new lib_1.SecurityGroup(stack, 'SecurityGroup3', { vpc, allowAllOutbound: false });
        const connections1 = new lib_1.Connections({ securityGroups: [sg1] });
        const connections2 = new lib_1.Connections({ securityGroups: [sg2] });
        const connectable = new SomethingConnectable(connections2);
        // WHEN
        connections1.allowTo(connectable, new lib_1.TcpPort(88));
        connections2.addSecurityGroup(sg3);
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroupIngress', {
            GroupId: { "Fn::GetAtt": ["SecurityGroup23BE86BB7", "GroupId"] },
            SourceSecurityGroupId: { "Fn::GetAtt": ["SecurityGroup1F554B36F", "GroupId"] },
            FromPort: 88,
            ToPort: 88
        }));
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroupIngress', {
            GroupId: { "Fn::GetAtt": ["SecurityGroup3E5E374B9", "GroupId"] },
            SourceSecurityGroupId: { "Fn::GetAtt": ["SecurityGroup1F554B36F", "GroupId"] },
            FromPort: 88,
            ToPort: 88
        }));
        test.done();
    },
    'multiple security groups allows internally between them'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.VpcNetwork(stack, 'VPC');
        const sg1 = new lib_1.SecurityGroup(stack, 'SecurityGroup1', { vpc, allowAllOutbound: false });
        const sg2 = new lib_1.SecurityGroup(stack, 'SecurityGroup2', { vpc, allowAllOutbound: false });
        const connections = new lib_1.Connections({ securityGroups: [sg1] });
        // WHEN
        connections.allowInternally(new lib_1.TcpPort(88));
        connections.addSecurityGroup(sg2);
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroupIngress', {
            GroupId: { "Fn::GetAtt": ["SecurityGroup1F554B36F", "GroupId"] },
            SourceSecurityGroupId: { "Fn::GetAtt": ["SecurityGroup1F554B36F", "GroupId"] },
            FromPort: 88,
            ToPort: 88
        }));
        test.done();
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5jb25uZWN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlc3QuY29ubmVjdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDRDQUF1RDtBQUN2RCxzQ0FBcUM7QUFHckMsZ0NBUWdCO0FBMkpoQixNQUFNLG9CQUFvQjtJQUN4QixZQUE0QixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtJQUNwRCxDQUFDO0NBQ0Y7QUE1SkQsaUJBQVM7SUFDUCxtRUFBbUUsQ0FBQyxJQUFVO1FBQzVFLFFBQVE7UUFDUixNQUFNLEtBQUssR0FBRyxJQUFJLFdBQUssQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLEVBQUMsQ0FBQyxDQUFDO1FBRWxHLE1BQU0sR0FBRyxHQUFHLElBQUksZ0JBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDekMsTUFBTSxHQUFHLEdBQUcsSUFBSSxtQkFBYSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sR0FBRyxHQUFHLElBQUksbUJBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUVyRCxNQUFNLEtBQUssR0FBRyxJQUFJLG9CQUFvQixDQUFDLElBQUksaUJBQVcsQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ25GLE1BQU0sS0FBSyxHQUFHLElBQUksb0JBQW9CLENBQUMsSUFBSSxpQkFBVyxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFbkYsT0FBTztRQUNQLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJ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Q2QsQ0FBQztDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHBlY3QsIGhhdmVSZXNvdXJjZSB9IGZyb20gJ0Bhd3MtY2RrL2Fzc2VydCc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0Bhd3MtY2RrL2Nkayc7XG5pbXBvcnQgeyBUZXN0IH0gZnJvbSAnbm9kZXVuaXQnO1xuXG5pbXBvcnQge1xuICBDb25uZWN0aW9ucyxcbiAgSUNvbm5lY3RhYmxlLFxuICBTZWN1cml0eUdyb3VwLFxuICBTZWN1cml0eUdyb3VwUmVmLFxuICBUY3BBbGxQb3J0cyxcbiAgVGNwUG9ydCxcbiAgVnBjTmV0d29ya1xufSBmcm9tIFwiLi4vbGliXCI7XG5cbmV4cG9ydCA9IHtcbiAgJ3BlZXJpbmcgYmV0d2VlbiB0d28gc2VjdXJpdHkgZ3JvdXBzIGRvZXMgbm90IHJlY3Vyc2l2ZSBpbmZpbml0ZWx5Jyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjayh1bmRlZmluZWQsICdUZXN0U3RhY2snLCB7IGVudjogeyBhY2NvdW50OiAnMTIzNDU2NzgnLCByZWdpb246ICdkdW1teScgfX0pO1xuXG4gICAgY29uc3QgdnBjID0gbmV3IFZwY05ldHdvcmsoc3RhY2ssICdWUEMnKTtcbiAgICBjb25zdCBzZzEgPSBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1NHMScsIHsgdnBjIH0pO1xuICAgIGNvbnN0IHNnMiA9IG5ldyBTZWN1cml0eUdyb3VwKHN0YWNrLCAnU0cyJywgeyB2cGMgfSk7XG5cbiAgICBjb25zdCBjb25uMSA9IG5ldyBTb21ldGhpbmdDb25uZWN0YWJsZShuZXcgQ29ubmVjdGlvbnMoeyBzZWN1cml0eUdyb3VwczogW3NnMV0gfSkpO1xuICAgIGNvbnN0IGNvbm4yID0gbmV3IFNvbWV0aGluZ0Nvbm5lY3RhYmxlKG5ldyBDb25uZWN0aW9ucyh7IHNlY3VyaXR5R3JvdXBzOiBbc2cyXSB9KSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29ubjEuY29ubmVjdGlvbnMuYWxsb3dUbyhjb25uMiwgbmV3IFRjcFBvcnQoODApLCAnVGVzdCcpO1xuXG4gICAgLy8gVEhFTiAtLSBpdCBmaW5pc2hlcyFcbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnKGltcG9ydGVkKSBTZWN1cml0eUdyb3VwIGNhbiBiZSB1c2VkIGFzIHRhcmdldCBvZiAuYWxsb3dUbygpJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGNOZXR3b3JrKHN0YWNrLCAnVlBDJyk7XG4gICAgY29uc3Qgc2cxID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTb21lU2VjdXJpdHlHcm91cCcsIHsgdnBjLCBhbGxvd0FsbE91dGJvdW5kOiBmYWxzZSB9KTtcbiAgICBjb25zdCBzb21ldGhpbmdDb25uZWN0YWJsZSA9IG5ldyBTb21ldGhpbmdDb25uZWN0YWJsZShuZXcgQ29ubmVjdGlvbnMoeyBzZWN1cml0eUdyb3VwczogW3NnMV0gfSkpO1xuXG4gICAgY29uc3Qgc2VjdXJpdHlHcm91cCA9IFNlY3VyaXR5R3JvdXBSZWYuaW1wb3J0KHN0YWNrLCAnSW1wb3J0ZWRTRycsIHsgc2VjdXJpdHlHcm91cElkOiAnc2ctMTIzNDUnIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIHNvbWV0aGluZ0Nvbm5lY3RhYmxlLmNvbm5lY3Rpb25zLmFsbG93VG8oc2VjdXJpdHlHcm91cCwgbmV3IFRjcEFsbFBvcnRzKCksICdDb25uZWN0IHRoZXJlJyk7XG5cbiAgICAvLyBUSEVOOiBydWxlIHRvIGdlbmVyYXRlZCBzZWN1cml0eSBncm91cCB0byBjb25uZWN0IHRvIGltcG9ydGVkXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoXCJBV1M6OkVDMjo6U2VjdXJpdHlHcm91cEVncmVzc1wiLCB7XG4gICAgICAgIEdyb3VwSWQ6IHsgXCJGbjo6R2V0QXR0XCI6IFsgXCJTb21lU2VjdXJpdHlHcm91cEVGMjE5QUQ2XCIsIFwiR3JvdXBJZFwiIF0gfSxcbiAgICAgICAgSXBQcm90b2NvbDogXCJ0Y3BcIixcbiAgICAgICAgRGVzY3JpcHRpb246IFwiQ29ubmVjdCB0aGVyZVwiLFxuICAgICAgICBEZXN0aW5hdGlvblNlY3VyaXR5R3JvdXBJZDogXCJzZy0xMjM0NVwiLFxuICAgICAgICBGcm9tUG9ydDogMCxcbiAgICAgICAgVG9Qb3J0OiA2NTUzNVxuICAgIH0pKTtcblxuICAgIC8vIFRIRU46IHJ1bGUgdG8gaW1wb3J0ZWQgc2VjdXJpdHkgZ3JvdXAgdG8gYWxsb3cgY29ubmVjdGlvbnMgZnJvbSBnZW5lcmF0ZWRcbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZShcIkFXUzo6RUMyOjpTZWN1cml0eUdyb3VwSW5ncmVzc1wiLCB7XG4gICAgICBJcFByb3RvY29sOiBcInRjcFwiLFxuICAgICAgRGVzY3JpcHRpb246IFwiQ29ubmVjdCB0aGVyZVwiLFxuICAgICAgRnJvbVBvcnQ6IDAsXG4gICAgICBHcm91cElkOiBcInNnLTEyMzQ1XCIsXG4gICAgICBTb3VyY2VTZWN1cml0eUdyb3VwSWQ6IHsgXCJGbjo6R2V0QXR0XCI6IFsgXCJTb21lU2VjdXJpdHlHcm91cEVGMjE5QUQ2XCIsIFwiR3JvdXBJZFwiIF0gfSxcbiAgICAgIFRvUG9ydDogNjU1MzVcbiAgICB9KSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnc2VjdXJpdHkgZ3JvdXBzIGFkZGVkIHRvIGNvbm5lY3Rpb25zIGFmdGVyIHJ1bGUgc3RpbGwgZ2V0cyBydWxlJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGNOZXR3b3JrKHN0YWNrLCAnVlBDJyk7XG4gICAgY29uc3Qgc2cxID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTZWN1cml0eUdyb3VwMScsIHsgdnBjLCBhbGxvd0FsbE91dGJvdW5kOiBmYWxzZSB9KTtcbiAgICBjb25zdCBzZzIgPSBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1NlY3VyaXR5R3JvdXAyJywgeyB2cGMsIGFsbG93QWxsT3V0Ym91bmQ6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gbmV3IENvbm5lY3Rpb25zKHsgc2VjdXJpdHlHcm91cHM6IFtzZzFdIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbm5lY3Rpb25zLmFsbG93RnJvbUFueUlQdjQobmV3IFRjcFBvcnQoODgpKTtcbiAgICBjb25uZWN0aW9ucy5hZGRTZWN1cml0eUdyb3VwKHNnMik7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwJywge1xuICAgICAgR3JvdXBEZXNjcmlwdGlvbjogXCJTZWN1cml0eUdyb3VwMVwiLFxuICAgICAgU2VjdXJpdHlHcm91cEluZ3Jlc3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIERlc2NyaXB0aW9uOiBcImZyb20gMC4wLjAuMC8wOjg4XCIsXG4gICAgICAgICAgQ2lkcklwOiBcIjAuMC4wLjAvMFwiLFxuICAgICAgICAgIEZyb21Qb3J0OiA4OCxcbiAgICAgICAgICBUb1BvcnQ6IDg4LFxuICAgICAgICAgIElwUHJvdG9jb2w6ICd0Y3AnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KSk7XG5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFQzI6OlNlY3VyaXR5R3JvdXAnLCB7XG4gICAgICBHcm91cERlc2NyaXB0aW9uOiBcIlNlY3VyaXR5R3JvdXAyXCIsXG4gICAgICBTZWN1cml0eUdyb3VwSW5ncmVzczogW1xuICAgICAgICB7XG4gICAgICAgICAgRGVzY3JpcHRpb246IFwiZnJvbSAwLjAuMC4wLzA6ODhcIixcbiAgICAgICAgICBDaWRySXA6IFwiMC4wLjAuMC8wXCIsXG4gICAgICAgICAgRnJvbVBvcnQ6IDg4LFxuICAgICAgICAgIFRvUG9ydDogODgsXG4gICAgICAgICAgSXBQcm90b2NvbDogJ3RjcCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICd3aGVuIHNlY3VyaXR5IGdyb3VwcyBhcmUgYWRkZWQgdG8gdGFyZ2V0IHRoZXkgYWxzbyBnZXQgdGhlIHJ1bGUnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwY05ldHdvcmsoc3RhY2ssICdWUEMnKTtcbiAgICBjb25zdCBzZzEgPSBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1NlY3VyaXR5R3JvdXAxJywgeyB2cGMsIGFsbG93QWxsT3V0Ym91bmQ6IGZhbHNlIH0pO1xuICAgIGNvbnN0IHNnMiA9IG5ldyBTZWN1cml0eUdyb3VwKHN0YWNrLCAnU2VjdXJpdHlHcm91cDInLCB7IHZwYywgYWxsb3dBbGxPdXRib3VuZDogZmFsc2UgfSk7XG4gICAgY29uc3Qgc2czID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTZWN1cml0eUdyb3VwMycsIHsgdnBjLCBhbGxvd0FsbE91dGJvdW5kOiBmYWxzZSB9KTtcbiAgICBjb25zdCBjb25uZWN0aW9uczEgPSBuZXcgQ29ubmVjdGlvbnMoeyBzZWN1cml0eUdyb3VwczogW3NnMV0gfSk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMyID0gbmV3IENvbm5lY3Rpb25zKHsgc2VjdXJpdHlHcm91cHM6IFtzZzJdIH0pO1xuICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gbmV3IFNvbWV0aGluZ0Nvbm5lY3RhYmxlKGNvbm5lY3Rpb25zMik7XG5cbiAgICAvLyBXSEVOXG4gICAgY29ubmVjdGlvbnMxLmFsbG93VG8oY29ubmVjdGFibGUsIG5ldyBUY3BQb3J0KDg4KSk7XG4gICAgY29ubmVjdGlvbnMyLmFkZFNlY3VyaXR5R3JvdXAoc2czKTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFQzI6OlNlY3VyaXR5R3JvdXBJbmdyZXNzJywge1xuICAgICAgR3JvdXBJZDogeyBcIkZuOjpHZXRBdHRcIjogWyBcIlNlY3VyaXR5R3JvdXAyM0JFODZCQjdcIiwgXCJHcm91cElkXCIgXSB9LFxuICAgICAgU291cmNlU2VjdXJpdHlHcm91cElkOiB7IFwiRm46OkdldEF0dFwiOiBbIFwiU2VjdXJpdHlHcm91cDFGNTU0QjM2RlwiLCBcIkdyb3VwSWRcIiBdIH0sXG4gICAgICBGcm9tUG9ydDogODgsXG4gICAgICBUb1BvcnQ6IDg4XG4gICAgfSkpO1xuXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwSW5ncmVzcycsIHtcbiAgICAgIEdyb3VwSWQ6IHsgXCJGbjo6R2V0QXR0XCI6IFsgXCJTZWN1cml0eUdyb3VwM0U1RTM3NEI5XCIsIFwiR3JvdXBJZFwiIF0gfSxcbiAgICAgIFNvdXJjZVNlY3VyaXR5R3JvdXBJZDogeyBcIkZuOjpHZXRBdHRcIjogWyBcIlNlY3VyaXR5R3JvdXAxRjU1NEIzNkZcIiwgXCJHcm91cElkXCIgXSB9LFxuICAgICAgRnJvbVBvcnQ6IDg4LFxuICAgICAgVG9Qb3J0OiA4OFxuICAgIH0pKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdtdWx0aXBsZSBzZWN1cml0eSBncm91cHMgYWxsb3dzIGludGVybmFsbHkgYmV0d2VlbiB0aGVtJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGNOZXR3b3JrKHN0YWNrLCAnVlBDJyk7XG4gICAgY29uc3Qgc2cxID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTZWN1cml0eUdyb3VwMScsIHsgdnBjLCBhbGxvd0FsbE91dGJvdW5kOiBmYWxzZSB9KTtcbiAgICBjb25zdCBzZzIgPSBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1NlY3VyaXR5R3JvdXAyJywgeyB2cGMsIGFsbG93QWxsT3V0Ym91bmQ6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gbmV3IENvbm5lY3Rpb25zKHsgc2VjdXJpdHlHcm91cHM6IFtzZzFdIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbm5lY3Rpb25zLmFsbG93SW50ZXJuYWxseShuZXcgVGNwUG9ydCg4OCkpO1xuICAgIGNvbm5lY3Rpb25zLmFkZFNlY3VyaXR5R3JvdXAoc2cyKTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFQzI6OlNlY3VyaXR5R3JvdXBJbmdyZXNzJywge1xuICAgICAgR3JvdXBJZDogeyBcIkZuOjpHZXRBdHRcIjogWyBcIlNlY3VyaXR5R3JvdXAxRjU1NEIzNkZcIiwgXCJHcm91cElkXCIgXSB9LFxuICAgICAgU291cmNlU2VjdXJpdHlHcm91cElkOiB7IFwiRm46OkdldEF0dFwiOiBbIFwiU2VjdXJpdHlHcm91cDFGNTU0QjM2RlwiLCBcIkdyb3VwSWRcIiBdIH0sXG4gICAgICBGcm9tUG9ydDogODgsXG4gICAgICBUb1BvcnQ6IDg4XG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG59O1xuXG5jbGFzcyBTb21ldGhpbmdDb25uZWN0YWJsZSBpbXBsZW1lbnRzIElDb25uZWN0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBjb25uZWN0aW9uczogQ29ubmVjdGlvbnMpIHtcbiAgfVxufVxuIl19