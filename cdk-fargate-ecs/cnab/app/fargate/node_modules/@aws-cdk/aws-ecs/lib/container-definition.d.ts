import iam = require('@aws-cdk/aws-iam');
import cdk = require('@aws-cdk/cdk');
import { TaskDefinition } from './base/task-definition';
import { IContainerImage } from './container-image';
import { cloudformation } from './ecs.generated';
import { LinuxParameters } from './linux-parameters';
import { LogDriver } from './log-drivers/log-driver';
/**
 * Properties of a container definition
 */
export interface ContainerDefinitionProps {
    /**
     * The image to use for a container.
     *
     * You can use images in the Docker Hub registry or specify other
     * repositories (repository-url/image:tag).
     * TODO: Update these to specify using classes of IContainerImage
     */
    image: IContainerImage;
    /**
     * The CMD value to pass to the container.
     *
     * If you provide a shell command as a single string, you have to quote command-line arguments.
     *
     * @default CMD value built into container image
     */
    command?: string[];
    /**
     * The minimum number of CPU units to reserve for the container.
     */
    cpu?: number;
    /**
     * Indicates whether networking is disabled within the container.
     *
     * @default false
     */
    disableNetworking?: boolean;
    /**
     * A list of DNS search domains that are provided to the container.
     *
     * @default No search domains
     */
    dnsSearchDomains?: string[];
    /**
     * A list of DNS servers that Amazon ECS provides to the container.
     *
     * @default Default DNS servers
     */
    dnsServers?: string[];
    /**
     * A key-value map of labels for the container.
     *
     * @default No labels
     */
    dockerLabels?: {
        [key: string]: string;
    };
    /**
     * A list of custom labels for SELinux and AppArmor multi-level security systems.
     *
     * @default No security labels
     */
    dockerSecurityOptions?: string[];
    /**
     * The ENTRYPOINT value to pass to the container.
     *
     * @see https://docs.docker.com/engine/reference/builder/#entrypoint
     * @default Entry point configured in container
     */
    entryPoint?: string[];
    /**
     * The environment variables to pass to the container.
     *
     * @default No environment variables
     */
    environment?: {
        [key: string]: string;
    };
    /**
     * Indicates whether the task stops if this container fails.
     *
     * If you specify true and the container fails, all other containers in the
     * task stop. If you specify false and the container fails, none of the other
     * containers in the task is affected.
     *
     * You must have at least one essential container in a task.
     *
     * @default true
     */
    essential?: boolean;
    /**
     * A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.
     *
     * @default No extra hosts
     */
    extraHosts?: {
        [name: string]: string;
    };
    /**
     * Container health check.
     *
     * @default Health check configuration from container
     */
    healthCheck?: HealthCheck;
    /**
     * The name that Docker uses for the container hostname.
     *
     * @default Automatic hostname
     */
    hostname?: string;
    /**
     * The hard limit (in MiB) of memory to present to the container.
     *
     * If your container attempts to exceed the allocated memory, the container
     * is terminated.
     *
     * At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services.
     */
    memoryLimitMiB?: number;
    /**
     * The soft limit (in MiB) of memory to reserve for the container.
     *
     * When system memory is under contention, Docker attempts to keep the
     * container memory within the limit. If the container requires more memory,
     * it can consume up to the value specified by the Memory property or all of
     * the available memory on the container instanceâ€”whichever comes first.
     *
     * At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services.
     */
    memoryReservationMiB?: number;
    /**
     * Indicates whether the container is given full access to the host container instance.
     *
     * @default false
     */
    privileged?: boolean;
    /**
     * Indicates whether the container's root file system is mounted as read only.
     *
     * @default false
     */
    readonlyRootFilesystem?: boolean;
    /**
     * The user name to use inside the container.
     *
     * @default root
     */
    user?: string;
    /**
     * The working directory in the container to run commands in.
     *
     * @default /
     */
    workingDirectory?: string;
    /**
     * Configures a custom log driver for the container.
     */
    logging?: LogDriver;
}
/**
 * A definition for a single container in a Task
 */
export declare class ContainerDefinition extends cdk.Construct {
    private readonly props;
    /**
     * Access Linux Parameters
     */
    readonly linuxParameters: LinuxParameters;
    /**
     * The configured mount points
     */
    readonly mountPoints: MountPoint[];
    /**
     * The configured port mappings
     */
    readonly portMappings: PortMapping[];
    /**
     * The configured volumes
     */
    readonly volumesFrom: VolumeFrom[];
    /**
     * The configured ulimits
     */
    readonly ulimits: Ulimit[];
    /**
     * Whether or not this container is essential
     */
    readonly essential: boolean;
    /**
     * Whether there was at least one memory limit specified in this definition
     */
    readonly memoryLimitSpecified: boolean;
    /**
     * The task definition this container definition is part of
     */
    readonly taskDefinition: TaskDefinition;
    /**
     * The configured container links
     */
    private readonly links;
    constructor(parent: cdk.Construct, id: string, taskDefinition: TaskDefinition, props: ContainerDefinitionProps);
    /**
     * Add a link from this container to a different container
     * The link parameter allows containers to communicate with each other without the need for port mappings.
     * Only supported if the network mode of a task definition is set to bridge.
     * Warning: The --link flag is a legacy feature of Docker. It may eventually be removed.
     */
    addLink(container: ContainerDefinition, alias?: string): void;
    /**
     * Add one or more mount points to this container.
     */
    addMountPoints(...mountPoints: MountPoint[]): void;
    /**
     * Mount temporary disc space to a container.
     * This adds the correct container mountPoint and task definition volume.
     */
    addScratch(scratch: ScratchSpace): void;
    /**
     * Add one or more port mappings to this container
     */
    addPortMappings(...portMappings: PortMapping[]): void;
    /**
     * Add one or more ulimits to this container
     */
    addUlimits(...ulimits: Ulimit[]): void;
    /**
     * Add one or more volumes to this container
     */
    addVolumesFrom(...volumesFrom: VolumeFrom[]): void;
    /**
     * Add a statement to the Task Definition's Execution policy
     */
    addToExecutionPolicy(statement: iam.PolicyStatement): void;
    /**
     * Ingress Port is needed to set the security group ingress for the task/service
     */
    readonly ingressPort: number;
    /**
     * Return the port that the container will be listening on by default
     */
    readonly containerPort: number;
    /**
     * Render this container definition to a CloudFormation object
     */
    renderContainerDefinition(): cloudformation.TaskDefinitionResource.ContainerDefinitionProperty;
}
/**
 * Container health check configuration
 */
export interface HealthCheck {
    /**
     * Command to run, as the binary path and arguments.
     *
     * If you provide a shell command as a single string, you have to quote command-line arguments.
     */
    command: string[];
    /**
     * Time period in seconds between each health check execution.
     *
     * You may specify between 5 and 300 seconds.
     *
     * @default 30
     */
    intervalSeconds?: number;
    /**
     * Number of times to retry a failed health check before the container is considered unhealthy.
     *
     * You may specify between 1 and 10 retries.
     *
     * @default 3
     */
    retries?: number;
    /**
     * Grace period after startup before failed health checks count.
     *
     * You may specify between 0 and 300 seconds.
     *
     * @default No start period
     */
    startPeriod?: number;
    /**
     * The time period in seconds to wait for a health check to succeed before it is considered a failure.
     *
     * You may specify between 2 and 60 seconds.
     *
     * @default 5
     */
    timeout?: number;
}
/**
 * Container ulimits.
 *
 * Correspond to ulimits options on docker run.
 *
 * NOTE: Does not work for Windows containers.
 */
export interface Ulimit {
    /**
     * What resource to enforce a limit on
     */
    name: UlimitName;
    /**
     * Soft limit of the resource
     */
    softLimit: number;
    /**
     * Hard limit of the resource
     */
    hardLimit: number;
}
/**
 * Type of resource to set a limit on
 */
export declare enum UlimitName {
    Core = "core",
    Cpu = "cpu",
    Data = "data",
    Fsize = "fsize",
    Locks = "locks",
    Memlock = "memlock",
    Msgqueue = "msgqueue",
    Nice = "nice",
    Nofile = "nofile",
    Nproc = "nproc",
    Rss = "rss",
    Rtprio = "rtprio",
    Rttime = "rttime",
    Sigpending = "sigpending",
    Stack = "stack"
}
/**
 * Map a host port to a container port
 */
export interface PortMapping {
    /**
     * Port inside the container
     */
    containerPort: number;
    /**
     * Port on the host
     *
     * In AwsVpc or Host networking mode, leave this out or set it to the
     * same value as containerPort.
     *
     * In Bridge networking mode, leave this out or set it to non-reserved
     * non-ephemeral port.
     */
    hostPort?: number;
    /**
     * Protocol
     *
     * @default Tcp
     */
    protocol?: Protocol;
}
/**
 * Network protocol
 */
export declare enum Protocol {
    /**
     * TCP
     */
    Tcp = "tcp",
    /**
     * UDP
     */
    Udp = "udp"
}
export interface ScratchSpace {
    containerPath: string;
    readOnly: boolean;
    sourcePath: string;
    name: string;
}
export interface MountPoint {
    containerPath: string;
    readOnly: boolean;
    sourceVolume: string;
}
/**
 * A volume from another container
 */
export interface VolumeFrom {
    /**
     * Name of the source container
     */
    sourceContainer: string;
    /**
     * Whether the volume is read only
     */
    readOnly: boolean;
}
