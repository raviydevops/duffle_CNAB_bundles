"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloudwatch = require("@aws-cdk/aws-cloudwatch");
const cdk = require("@aws-cdk/cdk");
const base_service_1 = require("../base/base-service");
const task_definition_1 = require("../base/task-definition");
const util_1 = require("../util");
/**
 * Start a service on an ECS cluster
 */
class Ec2Service extends base_service_1.BaseService {
    constructor(parent, name, props) {
        if (props.daemon && props.desiredCount !== undefined) {
            throw new Error('Daemon mode launches one task on every instance. Don\'t supply desiredCount.');
        }
        if (!util_1.isEc2Compatible(props.taskDefinition.compatibility)) {
            throw new Error('Supplied TaskDefinition is not configured for compatibility with EC2');
        }
        super(parent, name, Object.assign({}, props, { 
            // If daemon, desiredCount must be undefined and that's what we want. Otherwise, default to 1.
            desiredCount: props.daemon || props.desiredCount !== undefined ? props.desiredCount : 1 }), {
            cluster: props.cluster.clusterName,
            taskDefinition: props.taskDefinition.taskDefinitionArn,
            launchType: 'EC2',
            placementConstraints: new cdk.Token(() => this.constraints),
            placementStrategies: new cdk.Token(() => this.strategies),
            schedulingStrategy: props.daemon ? 'DAEMON' : 'REPLICA',
        }, props.cluster.clusterName, props.taskDefinition);
        this.cluster = props.cluster;
        this.clusterName = props.cluster.clusterName;
        this.constraints = [];
        this.strategies = [];
        this.daemon = props.daemon || false;
        if (props.taskDefinition.networkMode === task_definition_1.NetworkMode.AwsVpc) {
            this.configureAwsVpcNetworking(props.cluster.vpc, false, props.vpcPlacement, props.securityGroup);
        }
        else {
            // Either None, Bridge or Host networking. Copy SecurityGroup from ASG.
            validateNoNetworkingProps(props);
            this.connections.addSecurityGroup(...props.cluster.connections.securityGroups);
        }
        if (props.placeOnDistinctInstances) {
            this.constraints.push({ type: 'distinctInstance' });
        }
        if (!this.taskDefinition.defaultContainer) {
            throw new Error('A TaskDefinition must have at least one essential container');
        }
    }
    /**
     * Place services only on instances matching the given query expression
     *
     * You can specify multiple expressions in one call. The tasks will only
     * be placed on instances matching all expressions.
     *
     * @see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html
     */
    placeOnMemberOf(...expressions) {
        for (const expression of expressions) {
            this.constraints.push({ type: 'memberOf', expression });
        }
    }
    /**
     * Try to place tasks spread across instance attributes.
     *
     * You can use one of the built-in attributes found on `BuiltInAttributes`
     * or supply your own custom instance attributes. If more than one attribute
     * is supplied, spreading is done in order.
     *
     * @default attributes instanceId
     */
    placeSpreadAcross(...fields) {
        if (this.daemon) {
            throw new Error("Can't configure spreading placement for a service with daemon=true");
        }
        if (fields.length === 0) {
            fields = [BuiltInAttributes.InstanceId];
        }
        for (const field of fields) {
            this.strategies.push({ type: 'spread', field });
        }
    }
    /**
     * Try to place tasks on instances with the least amount of indicated resource available
     *
     * This ensures the total consumption of this resource is lowest.
     */
    placePackedBy(resource) {
        if (this.daemon) {
            throw new Error("Can't configure packing placement for a service with daemon=true");
        }
        this.strategies.push({ type: 'binpack', field: resource });
    }
    /**
     * Place tasks randomly across the available instances.
     */
    placeRandomly() {
        if (this.daemon) {
            throw new Error("Can't configure random placement for a service with daemon=true");
        }
        this.strategies.push({ type: 'random' });
    }
    /**
     * Register this service as the target of a Classic Load Balancer
     *
     * Don't call this. Call `loadBalancer.addTarget()` instead.
     */
    attachToClassicLB(loadBalancer) {
        if (this.taskDefinition.networkMode === task_definition_1.NetworkMode.Bridge) {
            throw new Error("Cannot use a Classic Load Balancer if NetworkMode is Bridge. Use Host or AwsVpc instead.");
        }
        if (this.taskDefinition.networkMode === task_definition_1.NetworkMode.None) {
            throw new Error("Cannot use a load balancer if NetworkMode is None. Use Host or AwsVpc instead.");
        }
        this.loadBalancers.push({
            loadBalancerName: loadBalancer.loadBalancerName,
            containerName: this.taskDefinition.defaultContainer.id,
            containerPort: this.taskDefinition.defaultContainer.containerPort,
        });
    }
    /**
     * Return the given named metric for this Service
     */
    metric(metricName, props) {
        return new cloudwatch.Metric(Object.assign({ namespace: 'AWS/ECS', metricName, dimensions: { ClusterName: this.clusterName, ServiceName: this.serviceName } }, props));
    }
    /**
     * Metric for cluster Memory utilization
     *
     * @default average over 5 minutes
     */
    metricMemoryUtilization(props) {
        return this.metric('MemoryUtilization', props);
    }
    /**
     * Metric for cluster CPU utilization
     *
     * @default average over 5 minutes
     */
    metricCpuUtilization(props) {
        return this.metric('CPUUtilization', props);
    }
    /**
     * Validate this Ec2Service
     */
    validate() {
        const ret = super.validate();
        if (!this.cluster.hasEc2Capacity) {
            ret.push('Cluster for this service needs Ec2 capacity. Call addXxxCapacity() on the cluster.');
        }
        return ret;
    }
}
exports.Ec2Service = Ec2Service;
/**
 * Validate combinations of networking arguments
 */
function validateNoNetworkingProps(props) {
    if (props.vpcPlacement !== undefined || props.securityGroup !== undefined) {
        throw new Error('vpcPlacement and securityGroup can only be used in AwsVpc networking mode');
    }
}
/**
 * Built-in container instance attributes
 */
class BuiltInAttributes {
}
/**
 * The Instance ID of the instance
 */
BuiltInAttributes.InstanceId = 'instanceId';
/**
 * The AZ where the instance is running
 */
BuiltInAttributes.AvailabilityZone = 'attribute:ecs.availability-zone';
/**
 * The AMI ID of the instance
 */
BuiltInAttributes.AmiId = 'attribute:ecs.ami-id';
/**
 * The instance type
 */
BuiltInAttributes.InstanceType = 'attribute:ecs.instance-type';
/**
 * The OS type
 *
 * Either 'linux' or 'windows'.
 */
BuiltInAttributes.OsType = 'attribute:ecs.os-type';
exports.BuiltInAttributes = BuiltInAttributes;
/**
 * Instance resource used for bin packing
 */
var BinPackResource;
(function (BinPackResource) {
    /**
     * Fill up hosts' CPU allocations first
     */
    BinPackResource["Cpu"] = "cpu";
    /**
     * Fill up hosts' memory allocations first
     */
    BinPackResource["Memory"] = "memory";
})(BinPackResource = exports.BinPackResource || (exports.BinPackResource = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWMyLXNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJlYzItc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHNEQUF3RDtBQUd4RCxvQ0FBcUM7QUFDckMsdURBQXFFO0FBQ3JFLDZEQUFzRTtBQUd0RSxrQ0FBMEM7QUFvRDFDOztHQUVHO0FBQ0gsTUFBYSxVQUFXLFNBQVEsMEJBQVc7SUFXekMsWUFBWSxNQUFxQixFQUFFLElBQVksRUFBRSxLQUFzQjtRQUNyRSxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7WUFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO1NBQ2pHO1FBRUQsSUFBSSxDQUFDLHNCQUFlLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4RCxNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7UUFFRCxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksb0JBQ2IsS0FBSztZQUNSLDhGQUE4RjtZQUM5RixZQUFZLEVBQUUsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUV6RjtZQUNFLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVc7WUFDbEMsY0FBYyxFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsaUJBQWlCO1lBQ3RELFVBQVUsRUFBRSxLQUFLO1lBQ2pCLG9CQUFvQixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQzNELG1CQUFtQixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lB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Q0FBQztJQUM5QyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ2IsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtZQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLG9GQUFvRixDQUFDLENBQUM7U0FDaEc7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7Q0FDRjtBQWpMRCxnQ0FpTEM7QUFFRDs7R0FFRztBQUNILFNBQVMseUJBQXlCLENBQUMsS0FBc0I7SUFDdkQsSUFBSSxLQUFLLENBQUMsWUFBWSxLQUFLLFNBQVMsSUFBSSxLQUFLLENBQUMsYUFBYSxLQUFLLFNBQVMsRUFBRTtRQUN6RSxNQUFNLElBQUksS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7S0FDOUY7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGlCQUFpQjs7QUFDNUI7O0dBRUc7QUFDb0IsNEJBQVUsR0FBRyxZQUFZLENBQUM7QUFFakQ7O0dBRUc7QUFDb0Isa0NBQWdCLEdBQUcsaUNBQWlDLENBQUM7QUFFNUU7O0dBRUc7QUFDb0IsdUJBQUssR0FBRyxzQkFBc0IsQ0FBQztBQUV0RDs7R0FFRztBQUNvQiw4QkFBWSxHQUFHLDZCQUE2QixDQUFDO0FBRXBFOzs7O0dBSUc7QUFDb0Isd0JBQU0sR0FBRyx1QkFBdUIsQ0FBQztBQTFCMUQsOENBMkJDO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLGVBVVg7QUFWRCxXQUFZLGVBQWU7SUFDekI7O09BRUc7SUFDSCw4QkFBVyxDQUFBO0lBRVg7O09BRUc7SUFDSCxvQ0FBaUIsQ0FBQTtBQUNuQixDQUFDLEVBVlcsZUFBZSxHQUFmLHVCQUFlLEtBQWYsdUJBQWUsUUFVMUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xvdWR3YXRjaCA9IHJlcXVpcmUgKCdAYXdzLWNkay9hd3MtY2xvdWR3YXRjaCcpO1xuaW1wb3J0IGVjMiA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2F3cy1lYzInKTtcbmltcG9ydCBlbGIgPSByZXF1aXJlKCdAYXdzLWNkay9hd3MtZWxhc3RpY2xvYWRiYWxhbmNpbmcnKTtcbmltcG9ydCBjZGsgPSByZXF1aXJlKCdAYXdzLWNkay9jZGsnKTtcbmltcG9ydCB7IEJhc2VTZXJ2aWNlLCBCYXNlU2VydmljZVByb3BzIH0gZnJvbSAnLi4vYmFzZS9iYXNlLXNlcnZpY2UnO1xuaW1wb3J0IHsgTmV0d29ya01vZGUsIFRhc2tEZWZpbml0aW9uIH0gZnJvbSAnLi4vYmFzZS90YXNrLWRlZmluaXRpb24nO1xuaW1wb3J0IHsgSUNsdXN0ZXIgfSBmcm9tICcuLi9jbHVzdGVyJztcbmltcG9ydCB7IGNsb3VkZm9ybWF0aW9uIH0gZnJvbSAnLi4vZWNzLmdlbmVyYXRlZCc7XG5pbXBvcnQgeyBpc0VjMkNvbXBhdGlibGUgfSBmcm9tICcuLi91dGlsJztcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRvIGRlZmluZSBhbiBFQ1Mgc2VydmljZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVjMlNlcnZpY2VQcm9wcyBleHRlbmRzIEJhc2VTZXJ2aWNlUHJvcHMge1xuICAvKipcbiAgICogQ2x1c3RlciB3aGVyZSBzZXJ2aWNlIHdpbGwgYmUgZGVwbG95ZWRcbiAgICovXG4gIGNsdXN0ZXI6IElDbHVzdGVyO1xuXG4gIC8qKlxuICAgKiBUYXNrIERlZmluaXRpb24gdXNlZCBmb3IgcnVubmluZyB0YXNrcyBpbiB0aGUgc2VydmljZVxuICAgKi9cbiAgdGFza0RlZmluaXRpb246IFRhc2tEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBJbiB3aGF0IHN1Ym5ldHMgdG8gcGxhY2UgdGhlIHRhc2sncyBFTklzXG4gICAqXG4gICAqIChPbmx5IGFwcGxpY2FibGUgaW4gY2FzZSB0aGUgVGFza0RlZmluaXRpb24gaXMgY29uZmlndXJlZCBmb3IgQXdzVnBjIG5ldHdvcmtpbmcpXG4gICAqXG4gICAqIEBkZWZhdWx0IFByaXZhdGUgc3VibmV0c1xuICAgKi9cbiAgdnBjUGxhY2VtZW50PzogZWMyLlZwY1BsYWNlbWVudFN0cmF0ZWd5O1xuXG4gIC8qKlxuICAgKiBFeGlzdGluZyBzZWN1cml0eSBncm91cCB0byB1c2UgZm9yIHRoZSB0YXNrJ3MgRU5Jc1xuICAgKlxuICAgKiAoT25seSBhcHBsaWNhYmxlIGluIGNhc2UgdGhlIFRhc2tEZWZpbml0aW9uIGlzIGNvbmZpZ3VyZWQgZm9yIEF3c1ZwYyBuZXR3b3JraW5nKVxuICAgKlxuICAgKiBAZGVmYXVsdCBBIG5ldyBzZWN1cml0eSBncm91cCBpcyBjcmVhdGVkXG4gICAqL1xuICBzZWN1cml0eUdyb3VwPzogZWMyLlNlY3VyaXR5R3JvdXBSZWY7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgc2VydmljZXMgb24gZGlzdGluY3QgaW5zdGFuY2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHBsYWNlT25EaXN0aW5jdEluc3RhbmNlcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERlcGxveSBleGFjdGx5IG9uZSB0YXNrIG9uIGVhY2ggaW5zdGFuY2UgaW4geW91ciBjbHVzdGVyLlxuICAgKlxuICAgKiBXaGVuIHVzaW5nIHRoaXMgc3RyYXRlZ3ksIGRvIG5vdCBzcGVjaWZ5IGEgZGVzaXJlZCBudW1iZXIgb2YgdGFza3Mgb3IgYW55XG4gICAqIHRhc2sgcGxhY2VtZW50IHN0cmF0ZWdpZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkYWVtb24/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFN0YXJ0IGEgc2VydmljZSBvbiBhbiBFQ1MgY2x1c3RlclxuICovXG5leHBvcnQgY2xhc3MgRWMyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIGltcGxlbWVudHMgZWxiLklMb2FkQmFsYW5jZXJUYXJnZXQge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNsdXN0ZXJOYW1lOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjb25zdHJhaW50czogY2xvdWRmb3JtYXRpb24uU2VydmljZVJlc291cmNlLlBsYWNlbWVudENvbnN0cmFpbnRQcm9wZXJ0eVtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0cmF0ZWdpZXM6IGNsb3VkZm9ybWF0aW9uLlNlcnZpY2VSZXNvdXJjZS5QbGFjZW1lbnRTdHJhdGVneVByb3BlcnR5W107XG4gIHByaXZhdGUgcmVhZG9ubHkgZGFlbW9uOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IGNsdXN0ZXI6IElDbHVzdGVyO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogY2RrLkNvbnN0cnVjdCwgbmFtZTogc3RyaW5nLCBwcm9wczogRWMyU2VydmljZVByb3BzKSB7XG4gICAgaWYgKHByb3BzLmRhZW1vbiAmJiBwcm9wcy5kZXNpcmVkQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYWVtb24gbW9kZSBsYXVuY2hlcyBvbmUgdGFzayBvbiBldmVyeSBpbnN0YW5jZS4gRG9uXFwndCBzdXBwbHkgZGVzaXJlZENvdW50LicpO1xuICAgIH1cblxuICAgIGlmICghaXNFYzJDb21wYXRpYmxlKHByb3BzLnRhc2tEZWZpbml0aW9uLmNvbXBhdGliaWxpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIFRhc2tEZWZpbml0aW9uIGlzIG5vdCBjb25maWd1cmVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRUMyJyk7XG4gICAgfVxuXG4gICAgc3VwZXIocGFyZW50LCBuYW1lLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIC8vIElmIGRhZW1vbiwgZGVzaXJlZENvdW50IG11c3QgYmUgdW5kZWZpbmVkIGFuZCB0aGF0J3Mgd2hhdCB3ZSB3YW50LiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gMS5cbiAgICAgIGRlc2lyZWRDb3VudDogcHJvcHMuZGFlbW9uIHx8IHByb3BzLmRlc2lyZWRDb3VudCAhPT0gdW5kZWZpbmVkID8gcHJvcHMuZGVzaXJlZENvdW50IDogMSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsdXN0ZXI6IHByb3BzLmNsdXN0ZXIuY2x1c3Rlck5hbWUsXG4gICAgICB0YXNrRGVmaW5pdGlvbjogcHJvcHMudGFza0RlZmluaXRpb24udGFza0RlZmluaXRpb25Bcm4sXG4gICAgICBsYXVuY2hUeXBlOiAnRUMyJyxcbiAgICAgIHBsYWNlbWVudENvbnN0cmFpbnRzOiBuZXcgY2RrLlRva2VuKCgpID0+IHRoaXMuY29uc3RyYWludHMpLFxuICAgICAgcGxhY2VtZW50U3RyYXRlZ2llczogbmV3IGNkay5Ub2tlbigoKSA9PiB0aGlzLnN0cmF0ZWdpZXMpLFxuICAgICAgc2NoZWR1bGluZ1N0cmF0ZWd5OiBwcm9wcy5kYWVtb24gPyAnREFFTU9OJyA6ICdSRVBMSUNBJyxcbiAgICB9LCBwcm9wcy5jbHVzdGVyLmNsdXN0ZXJOYW1lLCBwcm9wcy50YXNrRGVmaW5pdGlvbik7XG5cbiAgICB0aGlzLmNsdXN0ZXIgPSBwcm9wcy5jbHVzdGVyO1xuICAgIHRoaXMuY2x1c3Rlck5hbWUgPSBwcm9wcy5jbHVzdGVyLmNsdXN0ZXJOYW1lO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcbiAgICB0aGlzLnN0cmF0ZWdpZXMgPSBbXTtcbiAgICB0aGlzLmRhZW1vbiA9IHByb3BzLmRhZW1vbiB8fCBmYWxzZTtcblxuICAgIGlmIChwcm9wcy50YXNrRGVmaW5pdGlvbi5uZXR3b3JrTW9kZSA9PT0gTmV0d29ya01vZGUuQXdzVnBjKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyZUF3c1ZwY05ldHdvcmtpbmcocHJvcHMuY2x1c3Rlci52cGMsIGZhbHNlLCBwcm9wcy52cGNQbGFjZW1lbnQsIHByb3BzLnNlY3VyaXR5R3JvdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgTm9uZSwgQnJpZGdlIG9yIEhvc3QgbmV0d29ya2luZy4gQ29weSBTZWN1cml0eUdyb3VwIGZyb20gQVNHLlxuICAgICAgdmFsaWRhdGVOb05ldHdvcmtpbmdQcm9wcyhwcm9wcyk7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zLmFkZFNlY3VyaXR5R3JvdXAoLi4ucHJvcHMuY2x1c3Rlci5jb25uZWN0aW9ucy5zZWN1cml0eUdyb3Vwcyk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnBsYWNlT25EaXN0aW5jdEluc3RhbmNlcykge1xuICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKHsgdHlwZTogJ2Rpc3RpbmN0SW5zdGFuY2UnIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50YXNrRGVmaW5pdGlvbi5kZWZhdWx0Q29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgVGFza0RlZmluaXRpb24gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlc3NlbnRpYWwgY29udGFpbmVyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBsYWNlIHNlcnZpY2VzIG9ubHkgb24gaW5zdGFuY2VzIG1hdGNoaW5nIHRoZSBnaXZlbiBxdWVyeSBleHByZXNzaW9uXG4gICAqXG4gICAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSBleHByZXNzaW9ucyBpbiBvbmUgY2FsbC4gVGhlIHRhc2tzIHdpbGwgb25seVxuICAgKiBiZSBwbGFjZWQgb24gaW5zdGFuY2VzIG1hdGNoaW5nIGFsbCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9kZXZlbG9wZXJndWlkZS9jbHVzdGVyLXF1ZXJ5LWxhbmd1YWdlLmh0bWxcbiAgICovXG4gIHB1YmxpYyBwbGFjZU9uTWVtYmVyT2YoLi4uZXhwcmVzc2lvbnM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIGV4cHJlc3Npb25zKSB7XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goeyB0eXBlOiAnbWVtYmVyT2YnLCBleHByZXNzaW9uIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gcGxhY2UgdGFza3Mgc3ByZWFkIGFjcm9zcyBpbnN0YW5jZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIHVzZSBvbmUgb2YgdGhlIGJ1aWx0LWluIGF0dHJpYnV0ZXMgZm91bmQgb24gYEJ1aWx0SW5BdHRyaWJ1dGVzYFxuICAgKiBvciBzdXBwbHkgeW91ciBvd24gY3VzdG9tIGluc3RhbmNlIGF0dHJpYnV0ZXMuIElmIG1vcmUgdGhhbiBvbmUgYXR0cmlidXRlXG4gICAqIGlzIHN1cHBsaWVkLCBzcHJlYWRpbmcgaXMgZG9uZSBpbiBvcmRlci5cbiAgICpcbiAgICogQGRlZmF1bHQgYXR0cmlidXRlcyBpbnN0YW5jZUlkXG4gICAqL1xuICBwdWJsaWMgcGxhY2VTcHJlYWRBY3Jvc3MoLi4uZmllbGRzOiBzdHJpbmdbXSkge1xuICAgIGlmICh0aGlzLmRhZW1vbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29uZmlndXJlIHNwcmVhZGluZyBwbGFjZW1lbnQgZm9yIGEgc2VydmljZSB3aXRoIGRhZW1vbj10cnVlXCIpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmaWVsZHMgPSBbQnVpbHRJbkF0dHJpYnV0ZXMuSW5zdGFuY2VJZF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICB0aGlzLnN0cmF0ZWdpZXMucHVzaCh7IHR5cGU6ICdzcHJlYWQnLCBmaWVsZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIHBsYWNlIHRhc2tzIG9uIGluc3RhbmNlcyB3aXRoIHRoZSBsZWFzdCBhbW91bnQgb2YgaW5kaWNhdGVkIHJlc291cmNlIGF2YWlsYWJsZVxuICAgKlxuICAgKiBUaGlzIGVuc3VyZXMgdGhlIHRvdGFsIGNvbnN1bXB0aW9uIG9mIHRoaXMgcmVzb3VyY2UgaXMgbG93ZXN0LlxuICAgKi9cbiAgcHVibGljIHBsYWNlUGFja2VkQnkocmVzb3VyY2U6IEJpblBhY2tSZXNvdXJjZSkge1xuICAgIGlmICh0aGlzLmRhZW1vbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29uZmlndXJlIHBhY2tpbmcgcGxhY2VtZW50IGZvciBhIHNlcnZpY2Ugd2l0aCBkYWVtb249dHJ1ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmF0ZWdpZXMucHVzaCh7IHR5cGU6ICdiaW5wYWNrJywgZmllbGQ6IHJlc291cmNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYWNlIHRhc2tzIHJhbmRvbWx5IGFjcm9zcyB0aGUgYXZhaWxhYmxlIGluc3RhbmNlcy5cbiAgICovXG4gIHB1YmxpYyBwbGFjZVJhbmRvbWx5KCkge1xuICAgIGlmICh0aGlzLmRhZW1vbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29uZmlndXJlIHJhbmRvbSBwbGFjZW1lbnQgZm9yIGEgc2VydmljZSB3aXRoIGRhZW1vbj10cnVlXCIpO1xuICAgIH1cblxuICAgIHRoaXMuc3RyYXRlZ2llcy5wdXNoKHsgdHlwZTogJ3JhbmRvbScgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgdGhpcyBzZXJ2aWNlIGFzIHRoZSB0YXJnZXQgb2YgYSBDbGFzc2ljIExvYWQgQmFsYW5jZXJcbiAgICpcbiAgICogRG9uJ3QgY2FsbCB0aGlzLiBDYWxsIGBsb2FkQmFsYW5jZXIuYWRkVGFyZ2V0KClgIGluc3RlYWQuXG4gICAqL1xuICBwdWJsaWMgYXR0YWNoVG9DbGFzc2ljTEIobG9hZEJhbGFuY2VyOiBlbGIuTG9hZEJhbGFuY2VyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudGFza0RlZmluaXRpb24ubmV0d29ya01vZGUgPT09IE5ldHdvcmtNb2RlLkJyaWRnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBhIENsYXNzaWMgTG9hZCBCYWxhbmNlciBpZiBOZXR3b3JrTW9kZSBpcyBCcmlkZ2UuIFVzZSBIb3N0IG9yIEF3c1ZwYyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFza0RlZmluaXRpb24ubmV0d29ya01vZGUgPT09IE5ldHdvcmtNb2RlLk5vbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYSBsb2FkIGJhbGFuY2VyIGlmIE5ldHdvcmtNb2RlIGlzIE5vbmUuIFVzZSBIb3N0IG9yIEF3c1ZwYyBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRCYWxhbmNlcnMucHVzaCh7XG4gICAgICBsb2FkQmFsYW5jZXJOYW1lOiBsb2FkQmFsYW5jZXIubG9hZEJhbGFuY2VyTmFtZSxcbiAgICAgIGNvbnRhaW5lck5hbWU6IHRoaXMudGFza0RlZmluaXRpb24uZGVmYXVsdENvbnRhaW5lciEuaWQsXG4gICAgICBjb250YWluZXJQb3J0OiB0aGlzLnRhc2tEZWZpbml0aW9uLmRlZmF1bHRDb250YWluZXIhLmNvbnRhaW5lclBvcnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnaXZlbiBuYW1lZCBtZXRyaWMgZm9yIHRoaXMgU2VydmljZVxuICAgKi9cbiAgcHVibGljIG1ldHJpYyhtZXRyaWNOYW1lOiBzdHJpbmcsIHByb3BzPzogY2xvdWR3YXRjaC5NZXRyaWNDdXN0b21pemF0aW9uKTogY2xvdWR3YXRjaC5NZXRyaWMge1xuICAgIHJldHVybiBuZXcgY2xvdWR3YXRjaC5NZXRyaWMoe1xuICAgICAgbmFtZXNwYWNlOiAnQVdTL0VDUycsXG4gICAgICBtZXRyaWNOYW1lLFxuICAgICAgZGltZW5zaW9uczogeyBDbHVzdGVyTmFtZTogdGhpcy5jbHVzdGVyTmFtZSwgU2VydmljZU5hbWU6IHRoaXMuc2VydmljZU5hbWUgfSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0cmljIGZvciBjbHVzdGVyIE1lbW9yeSB1dGlsaXphdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCBhdmVyYWdlIG92ZXIgNSBtaW51dGVzXG4gICAqL1xuICBwdWJsaWMgbWV0cmljTWVtb3J5VXRpbGl6YXRpb24ocHJvcHM/OiBjbG91ZHdhdGNoLk1ldHJpY0N1c3RvbWl6YXRpb24pOiBjbG91ZHdhdGNoLk1ldHJpYyB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljKCdNZW1vcnlVdGlsaXphdGlvbicsIHByb3BzICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0cmljIGZvciBjbHVzdGVyIENQVSB1dGlsaXphdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCBhdmVyYWdlIG92ZXIgNSBtaW51dGVzXG4gICAqL1xuICBwdWJsaWMgbWV0cmljQ3B1VXRpbGl6YXRpb24ocHJvcHM/OiBjbG91ZHdhdGNoLk1ldHJpY0N1c3RvbWl6YXRpb24pOiBjbG91ZHdhdGNoLk1ldHJpYyB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljKCdDUFVVdGlsaXphdGlvbicsIHByb3BzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGlzIEVjMlNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB2YWxpZGF0ZSgpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmV0ID0gc3VwZXIudmFsaWRhdGUoKTtcbiAgICBpZiAoIXRoaXMuY2x1c3Rlci5oYXNFYzJDYXBhY2l0eSkge1xuICAgICAgcmV0LnB1c2goJ0NsdXN0ZXIgZm9yIHRoaXMgc2VydmljZSBuZWVkcyBFYzIgY2FwYWNpdHkuIENhbGwgYWRkWHh4Q2FwYWNpdHkoKSBvbiB0aGUgY2x1c3Rlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGNvbWJpbmF0aW9ucyBvZiBuZXR3b3JraW5nIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vTmV0d29ya2luZ1Byb3BzKHByb3BzOiBFYzJTZXJ2aWNlUHJvcHMpIHtcbiAgaWYgKHByb3BzLnZwY1BsYWNlbWVudCAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLnNlY3VyaXR5R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndnBjUGxhY2VtZW50IGFuZCBzZWN1cml0eUdyb3VwIGNhbiBvbmx5IGJlIHVzZWQgaW4gQXdzVnBjIG5ldHdvcmtpbmcgbW9kZScpO1xuICB9XG59XG5cbi8qKlxuICogQnVpbHQtaW4gY29udGFpbmVyIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEJ1aWx0SW5BdHRyaWJ1dGVzIHtcbiAgLyoqXG4gICAqIFRoZSBJbnN0YW5jZSBJRCBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSW5zdGFuY2VJZCA9ICdpbnN0YW5jZUlkJztcblxuICAvKipcbiAgICogVGhlIEFaIHdoZXJlIHRoZSBpbnN0YW5jZSBpcyBydW5uaW5nXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEF2YWlsYWJpbGl0eVpvbmUgPSAnYXR0cmlidXRlOmVjcy5hdmFpbGFiaWxpdHktem9uZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBBTUkgSUQgb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFtaUlkID0gJ2F0dHJpYnV0ZTplY3MuYW1pLWlkJztcblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIHR5cGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSW5zdGFuY2VUeXBlID0gJ2F0dHJpYnV0ZTplY3MuaW5zdGFuY2UtdHlwZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBPUyB0eXBlXG4gICAqXG4gICAqIEVpdGhlciAnbGludXgnIG9yICd3aW5kb3dzJy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3NUeXBlID0gJ2F0dHJpYnV0ZTplY3Mub3MtdHlwZSc7XG59XG5cbi8qKlxuICogSW5zdGFuY2UgcmVzb3VyY2UgdXNlZCBmb3IgYmluIHBhY2tpbmdcbiAqL1xuZXhwb3J0IGVudW0gQmluUGFja1Jlc291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGwgdXAgaG9zdHMnIENQVSBhbGxvY2F0aW9ucyBmaXJzdFxuICAgKi9cbiAgQ3B1ID0gJ2NwdScsXG5cbiAgLyoqXG4gICAqIEZpbGwgdXAgaG9zdHMnIG1lbW9yeSBhbGxvY2F0aW9ucyBmaXJzdFxuICAgKi9cbiAgTWVtb3J5ID0gJ21lbW9yeScsXG59XG4iXX0=