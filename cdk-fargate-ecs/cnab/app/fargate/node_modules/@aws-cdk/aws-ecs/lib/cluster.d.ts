import autoscaling = require('@aws-cdk/aws-autoscaling');
import cloudwatch = require('@aws-cdk/aws-cloudwatch');
import ec2 = require('@aws-cdk/aws-ec2');
import cdk = require('@aws-cdk/cdk');
/**
 * Properties to define an ECS cluster
 */
export interface ClusterProps {
    /**
     * A name for the cluster.
     *
     * @default CloudFormation-generated name
     */
    clusterName?: string;
    /**
     * The VPC where your ECS instances will be running or your ENIs will be deployed
     */
    vpc: ec2.VpcNetworkRef;
}
/**
 * A container cluster that runs on your EC2 instances
 */
export declare class Cluster extends cdk.Construct implements ICluster {
    /**
     * Import an existing cluster
     */
    static import(parent: cdk.Construct, name: string, props: ImportedClusterProps): ICluster;
    /**
     * Connections manager for the EC2 cluster
     */
    readonly connections: ec2.Connections;
    /**
     * The VPC this cluster was created in.
     */
    readonly vpc: ec2.VpcNetworkRef;
    /**
     * The ARN of this cluster
     */
    readonly clusterArn: string;
    /**
     * The name of this cluster
     */
    readonly clusterName: string;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    private _hasEc2Capacity;
    constructor(parent: cdk.Construct, name: string, props: ClusterProps);
    /**
     * Add a default-configured AutoScalingGroup running the ECS-optimized AMI to this Cluster
     *
     * Returns the AutoScalingGroup so you can add autoscaling settings to it.
     */
    addDefaultAutoScalingGroupCapacity(options: AddDefaultAutoScalingGroupOptions): autoscaling.AutoScalingGroup;
    /**
     * Add compute capacity to this ECS cluster in the form of an AutoScalingGroup
     */
    addAutoScalingGroupCapacity(autoScalingGroup: autoscaling.AutoScalingGroup, options?: AddAutoScalingGroupCapacityOptions): void;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    readonly hasEc2Capacity: boolean;
    /**
     * Export the Cluster
     */
    export(): ImportedClusterProps;
    /**
     * Metric for cluster CPU reservation
     *
     * @default average over 5 minutes
     */
    metricCpuReservation(props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
    /**
     * Metric for cluster Memory reservation
     *
     * @default average over 5 minutes
     */
    metricMemoryReservation(props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
    /**
     * Return the given named metric for this Cluster
     */
    metric(metricName: string, props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
}
/**
 * Construct a Linux machine image from the latest ECS Optimized AMI published in SSM
 */
export declare class EcsOptimizedAmi implements ec2.IMachineImageSource {
    private static AmiParameterName;
    /**
     * Return the correct image
     */
    getImage(parent: cdk.Construct): ec2.MachineImage;
}
/**
 * An ECS cluster
 */
export interface ICluster {
    /**
     * Name of the cluster
     */
    readonly clusterName: string;
    /**
     * VPC that the cluster instances are running in
     */
    readonly vpc: ec2.VpcNetworkRef;
    /**
     * Connections manager of the cluster instances
     */
    readonly connections: ec2.Connections;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    readonly hasEc2Capacity: boolean;
}
/**
 * Properties to import an ECS cluster
 */
export interface ImportedClusterProps {
    /**
     * Name of the cluster
     */
    clusterName: string;
    /**
     * VPC that the cluster instances are running in
     */
    vpc: ec2.VpcNetworkRefProps;
    /**
     * Security group of the cluster instances
     */
    securityGroups: ec2.SecurityGroupRefProps[];
    /**
     * Whether the given cluster has EC2 capacity
     *
     * @default true
     */
    hasEc2Capacity?: boolean;
}
/**
 * Properties for adding an autoScalingGroup
 */
export interface AddAutoScalingGroupCapacityOptions {
    /**
     * Whether or not the containers can access the instance role
     *
     * @default false
     */
    containersAccessInstanceRole?: boolean;
    /**
     * Give tasks this many seconds to complete when instances are being scaled in.
     *
     * Task draining adds a Lambda and a Lifecycle hook to your AutoScalingGroup
     * that will delay instance termination until all ECS tasks have drained from
     * the instance.
     *
     * Set to 0 to disable task draining.
     *
     * @default 300
     */
    taskDrainTimeSeconds?: number;
}
/**
 * Properties for adding autoScalingGroup
 */
export interface AddDefaultAutoScalingGroupOptions extends AddAutoScalingGroupCapacityOptions {
    /**
     * The type of EC2 instance to launch into your Autoscaling Group
     */
    instanceType: ec2.InstanceType;
    /**
     * Number of container instances registered in your ECS Cluster
     *
     * @default 1
     */
    instanceCount?: number;
    /**
     * Maximum number of instances
     *
     * @default Same as instanceCount
     */
    maxCapacity?: number;
    /**
     * Minimum number of instances
     *
     * @default Same as instanceCount
     */
    minCapacity?: number;
}
