"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const appscaling = require("@aws-cdk/aws-applicationautoscaling");
const cloudwatch = require("@aws-cdk/aws-cloudwatch");
const ec2 = require("@aws-cdk/aws-ec2");
const elbv2 = require("@aws-cdk/aws-elasticloadbalancingv2");
const iam = require("@aws-cdk/aws-iam");
const cdk = require("@aws-cdk/cdk");
const task_definition_1 = require("../base/task-definition");
const ecs_generated_1 = require("../ecs.generated");
const scalable_task_count_1 = require("./scalable-task-count");
/**
 * Base class for Ecs and Fargate services
 */
class BaseService extends cdk.Construct {
    constructor(parent, name, props, additionalProps, clusterName, taskDefinition) {
        super(parent, name);
        /**
         * Manage allowed network traffic for this service
         */
        this.connections = new ec2.Connections();
        this.loadBalancers = new Array();
        this.taskDefinition = taskDefinition;
        this.resource = new ecs_generated_1.cloudformation.ServiceResource(this, "Service", Object.assign({ desiredCount: props.desiredCount, serviceName: props.serviceName, loadBalancers: new cdk.Token(() => this.loadBalancers), deploymentConfiguration: {
                maximumPercent: props.maximumPercent || 200,
                minimumHealthyPercent: props.minimumHealthyPercent || 50
            }, healthCheckGracePeriodSeconds: props.healthCheckGracePeriodSeconds, 
            /* role: never specified, supplanted by Service Linked Role */
            networkConfiguration: new cdk.Token(() => this.networkConfiguration) }, additionalProps));
        this.serviceArn = this.resource.serviceArn;
        this.serviceName = this.resource.serviceName;
        this.dependencyElements = [this.resource];
        this.clusterName = clusterName;
    }
    /**
     * Called when the service is attached to an ALB
     *
     * Don't call this function directly. Instead, call listener.addTarget()
     * to add this service to a load balancer.
     */
    attachToApplicationTargetGroup(targetGroup) {
        const ret = this.attachToELBv2(targetGroup);
        // Open up security groups. For dynamic port mapping, we won't know the port range
        // in advance so we need to open up all ports.
        const port = this.taskDefinition.defaultContainer.ingressPort;
        const portRange = port === 0 ? EPHEMERAL_PORT_RANGE : new ec2.TcpPort(port);
        targetGroup.registerConnectable(this, portRange);
        return ret;
    }
    /**
     * Called when the service is attached to an NLB
     *
     * Don't call this function directly. Instead, call listener.addTarget()
     * to add this service to a load balancer.
     */
    attachToNetworkTargetGroup(targetGroup) {
        return this.attachToELBv2(targetGroup);
    }
    /**
     * Enable autoscaling for the number of tasks in this service
     */
    autoScaleTaskCount(props) {
        if (this.scalableTaskCount) {
            throw new Error('AutoScaling of task count already enabled for this service');
        }
        return this.scalableTaskCount = new scalable_task_count_1.ScalableTaskCount(this, 'TaskCount', Object.assign({ serviceNamespace: appscaling.ServiceNamespace.Ecs, resourceId: `service/${this.clusterName}/${this.resource.serviceName}`, dimension: 'ecs:service:DesiredCount', role: this.makeAutoScalingRole() }, props));
    }
    /**
     * Return the given named metric for this Service
     */
    metric(metricName, props) {
        return new cloudwatch.Metric(Object.assign({ namespace: 'AWS/ECS', metricName, dimensions: { ServiceName: this.serviceName } }, props));
    }
    /**
     * Set up AWSVPC networking for this construct
     */
    // tslint:disable-next-line:max-line-length
    configureAwsVpcNetworking(vpc, assignPublicIp, vpcPlacement, securityGroup) {
        if (vpcPlacement === undefined) {
            vpcPlacement = { subnetsToUse: assignPublicIp ? ec2.SubnetType.Public : ec2.SubnetType.Private };
        }
        if (securityGroup === undefined) {
            securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', { vpc });
        }
        const subnets = vpc.subnets(vpcPlacement);
        this.connections.addSecurityGroup(securityGroup);
        this.networkConfiguration = {
            awsvpcConfiguration: {
                assignPublicIp: assignPublicIp ? 'ENABLED' : 'DISABLED',
                subnets: subnets.map(x => x.subnetId),
                securityGroups: new cdk.Token(() => [securityGroup.securityGroupId]),
            }
        };
    }
    /**
     * Shared logic for attaching to an ELBv2
     */
    attachToELBv2(targetGroup) {
        if (this.taskDefinition.networkMode === task_definition_1.NetworkMode.None) {
            throw new Error("Cannot use a load balancer if NetworkMode is None. Use Bridge, Host or AwsVpc instead.");
        }
        this.loadBalancers.push({
            targetGroupArn: targetGroup.targetGroupArn,
            containerName: this.taskDefinition.defaultContainer.id,
            containerPort: this.taskDefinition.defaultContainer.containerPort,
        });
        this.resource.addDependency(targetGroup.loadBalancerDependency());
        const targetType = this.taskDefinition.networkMode === task_definition_1.NetworkMode.AwsVpc ? elbv2.TargetType.Ip : elbv2.TargetType.Instance;
        return { targetType };
    }
    /**
     * Generate the role that will be used for autoscaling this service
     */
    makeAutoScalingRole() {
        // Use a Service Linked Role.
        return iam.Role.import(this, 'ScalingRole', {
            roleArn: cdk.ArnUtils.fromComponents({
                service: 'iam',
                resource: 'role/aws-service-role/ecs.application-autoscaling.amazonaws.com',
                resourceName: 'AWSServiceRoleForApplicationAutoScaling_ECSService',
            })
        });
    }
}
exports.BaseService = BaseService;
/**
 * The port range to open up for dynamic port mapping
 */
const EPHEMERAL_PORT_RANGE = new ec2.TcpPortRange(32768, 65535);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYmFzZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsa0VBQW1FO0FBQ25FLHNEQUF1RDtBQUN2RCx3Q0FBeUM7QUFDekMsNkRBQThEO0FBQzlELHdDQUF5QztBQUN6QyxvQ0FBcUM7QUFDckMsNkRBQXNFO0FBQ3RFLG9EQUFrRDtBQUNsRCwrREFBMEQ7QUE4QzFEOztHQUVHO0FBQ0gsTUFBc0IsV0FBWSxTQUFRLEdBQUcsQ0FBQyxTQUFTO0lBc0NyRCxZQUFZLE1BQXFCLEVBQ3JCLElBQVksRUFDWixLQUF1QixFQUN2QixlQUFvQixFQUNwQixXQUFtQixFQUNuQixjQUE4QjtRQUN4QyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBcEN0Qjs7V0FFRztRQUNhLGdCQUFXLEdBQW9CLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBc0IzRCxrQkFBYSxHQUFHLElBQUksS0FBSyxFQUF1RCxDQUFDO1FBYXpGLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO1FBRXJDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSw4QkFBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxrQkFDaEUsWUFBWSxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQ2hDLFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVyxFQUM5QixhQUFhLEVBQUUsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFDdEQsdUJBQXVCLEVBQUU7Z0JBQ3ZCLGNBQWMsRUFBRSxLQUFLLENBQUMsY0FBYyxJQUFJLEdBQUc7Z0JBQzNDLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxxQkFBcUIsSUFBSSxFQUFFO2FBQ3pELEVBQ0QsNkJBQTZCLEVBQUUsS0FBSyxDQUFDLDZCQUE2QjtZQUNsRSw4REFBOEQ7WUFDOUQsb0JB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LEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSyxtQkFBbUI7UUFDekIsNkJBQTZCO1FBQzdCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRTtZQUMxQyxPQUFPLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUM7Z0JBQ25DLE9BQU8sRUFBRSxLQUFLO2dCQUNkLFFBQVEsRUFBRSxpRUFBaUU7Z0JBQzNFLFlBQVksRUFBRSxvREFBb0Q7YUFDbkUsQ0FBQztTQUNILENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQXBMRCxrQ0FvTEM7QUFFRDs7R0FFRztBQUNILE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcHBzY2FsaW5nID0gcmVxdWlyZSgnQGF3cy1jZGsvYXdzLWFwcGxpY2F0aW9uYXV0b3NjYWxpbmcnKTtcbmltcG9ydCBjbG91ZHdhdGNoID0gcmVxdWlyZSgnQGF3cy1jZGsvYXdzLWNsb3Vkd2F0Y2gnKTtcbmltcG9ydCBlYzIgPSByZXF1aXJlKCdAYXdzLWNkay9hd3MtZWMyJyk7XG5pbXBvcnQgZWxidjIgPSByZXF1aXJlKCdAYXdzLWNkay9hd3MtZWxhc3RpY2xvYWRiYWxhbmNpbmd2MicpO1xuaW1wb3J0IGlhbSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2F3cy1pYW0nKTtcbmltcG9ydCBjZGsgPSByZXF1aXJlKCdAYXdzLWNkay9jZGsnKTtcbmltcG9ydCB7IE5ldHdvcmtNb2RlLCBUYXNrRGVmaW5pdGlvbiB9IGZyb20gJy4uL2Jhc2UvdGFzay1kZWZpbml0aW9uJztcbmltcG9ydCB7IGNsb3VkZm9ybWF0aW9uIH0gZnJvbSAnLi4vZWNzLmdlbmVyYXRlZCc7XG5pbXBvcnQgeyBTY2FsYWJsZVRhc2tDb3VudCB9IGZyb20gJy4vc2NhbGFibGUtdGFzay1jb3VudCc7XG5cbi8qKlxuICogQmFzaWMgc2VydmljZSBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVNlcnZpY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgZGVzaXJlZCBjb3BpZXMgb2YgcnVubmluZyB0YXNrc1xuICAgKlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBkZXNpcmVkQ291bnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgbmFtZSBmb3IgdGhlIHNlcnZpY2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IENsb3VkRm9ybWF0aW9uLWdlbmVyYXRlZCBuYW1lXG4gICAqL1xuICBzZXJ2aWNlTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzLCBzcGVjaWZpZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBBbWF6b24gRUNTXG4gICAqIHNlcnZpY2UncyBEZXNpcmVkQ291bnQgdmFsdWUsIHRoYXQgY2FuIHJ1biBpbiBhIHNlcnZpY2UgZHVyaW5nIGFcbiAgICogZGVwbG95bWVudC5cbiAgICpcbiAgICogQGRlZmF1bHQgMjAwXG4gICAqL1xuICBtYXhpbXVtUGVyY2VudD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1pbmltdW0gbnVtYmVyIG9mIHRhc2tzLCBzcGVjaWZpZWQgYXMgYSBwZXJjZW50YWdlIG9mXG4gICAqIHRoZSBBbWF6b24gRUNTIHNlcnZpY2UncyBEZXNpcmVkQ291bnQgdmFsdWUsIHRoYXQgbXVzdFxuICAgKiBjb250aW51ZSB0byBydW4gYW5kIHJlbWFpbiBoZWFsdGh5IGR1cmluZyBhIGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IDUwXG4gICAqL1xuICBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRpbWUgYWZ0ZXIgc3RhcnR1cCB0byBpZ25vcmUgdW5oZWFsdGh5IGxvYWQgYmFsYW5jZXIgY2hlY2tzLlxuICAgKlxuICAgKiBAZGVmYXVsdCA/Pz8gRklYTUVcbiAgICovXG4gIGhlYWx0aENoZWNrR3JhY2VQZXJpb2RTZWNvbmRzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIEVjcyBhbmQgRmFyZ2F0ZSBzZXJ2aWNlc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVNlcnZpY2UgZXh0ZW5kcyBjZGsuQ29uc3RydWN0XG4gIGltcGxlbWVudHMgZWxidjIuSUFwcGxpY2F0aW9uTG9hZEJhbGFuY2VyVGFyZ2V0LCBlbGJ2Mi5JTmV0d29ya0xvYWRCYWxhbmNlclRhcmdldCwgY2RrLklEZXBlbmRhYmxlIHtcblxuICAvKipcbiAgICogQ2xvdWRGb3JtYXRpb24gcmVzb3VyY2VzIGdlbmVyYXRlZCBieSB0aGlzIHNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBkZXBlbmRlbmN5RWxlbWVudHM6IGNkay5JRGVwZW5kYWJsZVtdO1xuXG4gIC8qKlxuICAgKiBNYW5hZ2UgYWxsb3dlZCBuZXR3b3JrIHRyYWZmaWMgZm9yIHRoaXMgc2VydmljZVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBlYzIuQ29ubmVjdGlvbnMgPSBuZXcgZWMyLkNvbm5lY3Rpb25zKCk7XG5cbiAgLyoqXG4gICAqIEFSTiBvZiB0aGlzIHNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhpcyBzZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGlzIHNlcnZpY2UncyBjbHVzdGVyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY2x1c3Rlck5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGFzayBkZWZpbml0aW9uIHRoaXMgc2VydmljZSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB0YXNrRGVmaW5pdGlvbjogVGFza0RlZmluaXRpb247XG5cbiAgcHJvdGVjdGVkIGxvYWRCYWxhbmNlcnMgPSBuZXcgQXJyYXk8Y2xvdWRmb3JtYXRpb24uU2VydmljZVJlc291cmNlLkxvYWRCYWxhbmNlclByb3BlcnR5PigpO1xuICBwcm90ZWN0ZWQgbmV0d29ya0NvbmZpZ3VyYXRpb24/OiBjbG91ZGZvcm1hdGlvbi5TZXJ2aWNlUmVzb3VyY2UuTmV0d29ya0NvbmZpZ3VyYXRpb25Qcm9wZXJ0eTtcbiAgcHJpdmF0ZSByZWFkb25seSByZXNvdXJjZTogY2xvdWRmb3JtYXRpb24uU2VydmljZVJlc291cmNlO1xuICBwcml2YXRlIHNjYWxhYmxlVGFza0NvdW50PzogU2NhbGFibGVUYXNrQ291bnQ7XG5cbiAgY29uc3RydWN0b3IocGFyZW50OiBjZGsuQ29uc3RydWN0LFxuICAgICAgICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgIHByb3BzOiBCYXNlU2VydmljZVByb3BzLFxuICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcHM6IGFueSxcbiAgICAgICAgICAgICAgY2x1c3Rlck5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgdGFza0RlZmluaXRpb246IFRhc2tEZWZpbml0aW9uKSB7XG4gICAgc3VwZXIocGFyZW50LCBuYW1lKTtcblxuICAgIHRoaXMudGFza0RlZmluaXRpb24gPSB0YXNrRGVmaW5pdGlvbjtcblxuICAgIHRoaXMucmVzb3VyY2UgPSBuZXcgY2xvdWRmb3JtYXRpb24uU2VydmljZVJlc291cmNlKHRoaXMsIFwiU2VydmljZVwiLCB7XG4gICAgICBkZXNpcmVkQ291bnQ6IHByb3BzLmRlc2lyZWRDb3VudCxcbiAgICAgIHNlcnZpY2VOYW1lOiBwcm9wcy5zZXJ2aWNlTmFtZSxcbiAgICAgIGxvYWRCYWxhbmNlcnM6IG5ldyBjZGsuVG9rZW4oKCkgPT4gdGhpcy5sb2FkQmFsYW5jZXJzKSxcbiAgICAgIGRlcGxveW1lbnRDb25maWd1cmF0aW9uOiB7XG4gICAgICAgIG1heGltdW1QZXJjZW50OiBwcm9wcy5tYXhpbXVtUGVyY2VudCB8fCAyMDAsXG4gICAgICAgIG1pbmltdW1IZWFsdGh5UGVyY2VudDogcHJvcHMubWluaW11bUhlYWx0aHlQZXJjZW50IHx8IDUwXG4gICAgICB9LFxuICAgICAgaGVhbHRoQ2hlY2tHcmFjZVBlcmlvZFNlY29uZHM6IHByb3BzLmhlYWx0aENoZWNrR3JhY2VQZXJpb2RTZWNvbmRzLFxuICAgICAgLyogcm9sZTogbmV2ZXIgc3BlY2lmaWVkLCBzdXBwbGFudGVkIGJ5IFNlcnZpY2UgTGlua2VkIFJvbGUgKi9cbiAgICAgIG5ldHdvcmtDb25maWd1cmF0aW9uOiBuZXcgY2RrLlRva2VuKCgpID0+IHRoaXMubmV0d29ya0NvbmZpZ3VyYXRpb24pLFxuICAgICAgLi4uYWRkaXRpb25hbFByb3BzXG4gICAgfSk7XG4gICAgdGhpcy5zZXJ2aWNlQXJuID0gdGhpcy5yZXNvdXJjZS5zZXJ2aWNlQXJuO1xuICAgIHRoaXMuc2VydmljZU5hbWUgPSB0aGlzLnJlc291cmNlLnNlcnZpY2VOYW1lO1xuICAgIHRoaXMuZGVwZW5kZW5jeUVsZW1lbnRzID0gW3RoaXMucmVzb3VyY2VdO1xuICAgIHRoaXMuY2x1c3Rlck5hbWUgPSBjbHVzdGVyTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmljZSBpcyBhdHRhY2hlZCB0byBhbiBBTEJcbiAgICpcbiAgICogRG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5LiBJbnN0ZWFkLCBjYWxsIGxpc3RlbmVyLmFkZFRhcmdldCgpXG4gICAqIHRvIGFkZCB0aGlzIHNlcnZpY2UgdG8gYSBsb2FkIGJhbGFuY2VyLlxuICAgKi9cbiAgcHVibGljIGF0dGFjaFRvQXBwbGljYXRpb25UYXJnZXRHcm91cCh0YXJnZXRHcm91cDogZWxidjIuQXBwbGljYXRpb25UYXJnZXRHcm91cCk6IGVsYnYyLkxvYWRCYWxhbmNlclRhcmdldFByb3BzIHtcbiAgICBjb25zdCByZXQgPSB0aGlzLmF0dGFjaFRvRUxCdjIodGFyZ2V0R3JvdXApO1xuXG4gICAgLy8gT3BlbiB1cCBzZWN1cml0eSBncm91cHMuIEZvciBkeW5hbWljIHBvcnQgbWFwcGluZywgd2Ugd29uJ3Qga25vdyB0aGUgcG9ydCByYW5nZVxuICAgIC8vIGluIGFkdmFuY2Ugc28gd2UgbmVlZCB0byBvcGVuIHVwIGFsbCBwb3J0cy5cbiAgICBjb25zdCBwb3J0ID0gdGhpcy50YXNrRGVmaW5pdGlvbi5kZWZhdWx0Q29udGFpbmVyIS5pbmdyZXNzUG9ydDtcbiAgICBjb25zdCBwb3J0UmFuZ2UgPSBwb3J0ID09PSAwID8gRVBIRU1FUkFMX1BPUlRfUkFOR0UgOiBuZXcgZWMyLlRjcFBvcnQocG9ydCk7XG4gICAgdGFyZ2V0R3JvdXAucmVnaXN0ZXJDb25uZWN0YWJsZSh0aGlzLCBwb3J0UmFuZ2UpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmljZSBpcyBhdHRhY2hlZCB0byBhbiBOTEJcbiAgICpcbiAgICogRG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5LiBJbnN0ZWFkLCBjYWxsIGxpc3RlbmVyLmFkZFRhcmdldCgpXG4gICAqIHRvIGFkZCB0aGlzIHNlcnZpY2UgdG8gYSBsb2FkIGJhbGFuY2VyLlxuICAgKi9cbiAgcHVibGljIGF0dGFjaFRvTmV0d29ya1RhcmdldEdyb3VwKHRhcmdldEdyb3VwOiBlbGJ2Mi5OZXR3b3JrVGFyZ2V0R3JvdXApOiBlbGJ2Mi5Mb2FkQmFsYW5jZXJUYXJnZXRQcm9wcyB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoVG9FTEJ2Mih0YXJnZXRHcm91cCk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIGF1dG9zY2FsaW5nIGZvciB0aGUgbnVtYmVyIG9mIHRhc2tzIGluIHRoaXMgc2VydmljZVxuICAgKi9cbiAgcHVibGljIGF1dG9TY2FsZVRhc2tDb3VudChwcm9wczogYXBwc2NhbGluZy5FbmFibGVTY2FsaW5nUHJvcHMpIHtcbiAgICBpZiAodGhpcy5zY2FsYWJsZVRhc2tDb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvU2NhbGluZyBvZiB0YXNrIGNvdW50IGFscmVhZHkgZW5hYmxlZCBmb3IgdGhpcyBzZXJ2aWNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2NhbGFibGVUYXNrQ291bnQgPSBuZXcgU2NhbGFibGVUYXNrQ291bnQodGhpcywgJ1Rhc2tDb3VudCcsIHtcbiAgICAgIHNlcnZpY2VOYW1lc3BhY2U6IGFwcHNjYWxpbmcuU2VydmljZU5hbWVzcGFjZS5FY3MsXG4gICAgICByZXNvdXJjZUlkOiBgc2VydmljZS8ke3RoaXMuY2x1c3Rlck5hbWV9LyR7dGhpcy5yZXNvdXJjZS5zZXJ2aWNlTmFtZX1gLFxuICAgICAgZGltZW5zaW9uOiAnZWNzOnNlcnZpY2U6RGVzaXJlZENvdW50JyxcbiAgICAgIHJvbGU6IHRoaXMubWFrZUF1dG9TY2FsaW5nUm9sZSgpLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGdpdmVuIG5hbWVkIG1ldHJpYyBmb3IgdGhpcyBTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgbWV0cmljKG1ldHJpY05hbWU6IHN0cmluZywgcHJvcHM/OiBjbG91ZHdhdGNoLk1ldHJpY0N1c3RvbWl6YXRpb24pOiBjbG91ZHdhdGNoLk1ldHJpYyB7XG4gICAgcmV0dXJuIG5ldyBjbG91ZHdhdGNoLk1ldHJpYyh7XG4gICAgICBuYW1lc3BhY2U6ICdBV1MvRUNTJyxcbiAgICAgIG1ldHJpY05hbWUsXG4gICAgICBkaW1lbnNpb25zOiB7IFNlcnZpY2VOYW1lOiB0aGlzLnNlcnZpY2VOYW1lIH0sXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBBV1NWUEMgbmV0d29ya2luZyBmb3IgdGhpcyBjb25zdHJ1Y3RcbiAgICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgcHJvdGVjdGVkIGNvbmZpZ3VyZUF3c1ZwY05ldHdvcmtpbmcodnBjOiBlYzIuVnBjTmV0d29ya1JlZiwgYXNzaWduUHVibGljSXA/OiBib29sZWFuLCB2cGNQbGFjZW1lbnQ/OiBlYzIuVnBjUGxhY2VtZW50U3RyYXRlZ3ksIHNlY3VyaXR5R3JvdXA/OiBlYzIuU2VjdXJpdHlHcm91cFJlZikge1xuICAgIGlmICh2cGNQbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdnBjUGxhY2VtZW50ID0geyBzdWJuZXRzVG9Vc2U6IGFzc2lnblB1YmxpY0lwID8gZWMyLlN1Ym5ldFR5cGUuUHVibGljIDogZWMyLlN1Ym5ldFR5cGUuUHJpdmF0ZSB9O1xuICAgIH1cbiAgICBpZiAoc2VjdXJpdHlHcm91cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWN1cml0eUdyb3VwID0gbmV3IGVjMi5TZWN1cml0eUdyb3VwKHRoaXMsICdTZWN1cml0eUdyb3VwJywgeyB2cGMgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN1Ym5ldHMgPSB2cGMuc3VibmV0cyh2cGNQbGFjZW1lbnQpO1xuICAgIHRoaXMuY29ubmVjdGlvbnMuYWRkU2VjdXJpdHlHcm91cChzZWN1cml0eUdyb3VwKTtcblxuICAgIHRoaXMubmV0d29ya0NvbmZpZ3VyYXRpb24gPSB7XG4gICAgICBhd3N2cGNDb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGFzc2lnblB1YmxpY0lwOiBhc3NpZ25QdWJsaWNJcCA/ICdFTkFCTEVEJyA6ICdESVNBQkxFRCcsXG4gICAgICAgIHN1Ym5ldHM6IHN1Ym5ldHMubWFwKHggPT4geC5zdWJuZXRJZCksXG4gICAgICAgIHNlY3VyaXR5R3JvdXBzOiBuZXcgY2RrLlRva2VuKCgpID0+IFtzZWN1cml0eUdyb3VwIS5zZWN1cml0eUdyb3VwSWRdKSxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYXJlZCBsb2dpYyBmb3IgYXR0YWNoaW5nIHRvIGFuIEVMQnYyXG4gICAqL1xuICBwcml2YXRlIGF0dGFjaFRvRUxCdjIodGFyZ2V0R3JvdXA6IGVsYnYyLklUYXJnZXRHcm91cCk6IGVsYnYyLkxvYWRCYWxhbmNlclRhcmdldFByb3BzIHtcbiAgICBpZiAodGhpcy50YXNrRGVmaW5pdGlvbi5uZXR3b3JrTW9kZSA9PT0gTmV0d29ya01vZGUuTm9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBhIGxvYWQgYmFsYW5jZXIgaWYgTmV0d29ya01vZGUgaXMgTm9uZS4gVXNlIEJyaWRnZSwgSG9zdCBvciBBd3NWcGMgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkQmFsYW5jZXJzLnB1c2goe1xuICAgICAgdGFyZ2V0R3JvdXBBcm46IHRhcmdldEdyb3VwLnRhcmdldEdyb3VwQXJuLFxuICAgICAgY29udGFpbmVyTmFtZTogdGhpcy50YXNrRGVmaW5pdGlvbi5kZWZhdWx0Q29udGFpbmVyIS5pZCxcbiAgICAgIGNvbnRhaW5lclBvcnQ6IHRoaXMudGFza0RlZmluaXRpb24uZGVmYXVsdENvbnRhaW5lciEuY29udGFpbmVyUG9ydCxcbiAgICB9KTtcblxuICAgIHRoaXMucmVzb3VyY2UuYWRkRGVwZW5kZW5jeSh0YXJnZXRHcm91cC5sb2FkQmFsYW5jZXJEZXBlbmRlbmN5KCkpO1xuXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IHRoaXMudGFza0RlZmluaXRpb24ubmV0d29ya01vZGUgPT09IE5ldHdvcmtNb2RlLkF3c1ZwYyA/IGVsYnYyLlRhcmdldFR5cGUuSXAgOiBlbGJ2Mi5UYXJnZXRUeXBlLkluc3RhbmNlO1xuICAgIHJldHVybiB7IHRhcmdldFR5cGUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0aGUgcm9sZSB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXV0b3NjYWxpbmcgdGhpcyBzZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIG1ha2VBdXRvU2NhbGluZ1JvbGUoKTogaWFtLklSb2xlIHtcbiAgICAvLyBVc2UgYSBTZXJ2aWNlIExpbmtlZCBSb2xlLlxuICAgIHJldHVybiBpYW0uUm9sZS5pbXBvcnQodGhpcywgJ1NjYWxpbmdSb2xlJywge1xuICAgICAgcm9sZUFybjogY2RrLkFyblV0aWxzLmZyb21Db21wb25lbnRzKHtcbiAgICAgICAgc2VydmljZTogJ2lhbScsXG4gICAgICAgIHJlc291cmNlOiAncm9sZS9hd3Mtc2VydmljZS1yb2xlL2Vjcy5hcHBsaWNhdGlvbi1hdXRvc2NhbGluZy5hbWF6b25hd3MuY29tJyxcbiAgICAgICAgcmVzb3VyY2VOYW1lOiAnQVdTU2VydmljZVJvbGVGb3JBcHBsaWNhdGlvbkF1dG9TY2FsaW5nX0VDU1NlcnZpY2UnLFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBwb3J0IHJhbmdlIHRvIG9wZW4gdXAgZm9yIGR5bmFtaWMgcG9ydCBtYXBwaW5nXG4gKi9cbmNvbnN0IEVQSEVNRVJBTF9QT1JUX1JBTkdFID0gbmV3IGVjMi5UY3BQb3J0UmFuZ2UoMzI3NjgsIDY1NTM1KTtcbiJdfQ==