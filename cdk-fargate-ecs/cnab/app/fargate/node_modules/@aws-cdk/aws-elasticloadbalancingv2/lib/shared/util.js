"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const enums_1 = require("./enums");
/**
 * Render an attribute dict to a list of { key, value } pairs
 */
function renderAttributes(attributes) {
    const ret = [];
    for (const [key, value] of Object.entries(attributes)) {
        if (value !== undefined) {
            ret.push({ key, value });
        }
    }
    return ret;
}
exports.renderAttributes = renderAttributes;
/**
 * Return the appropriate default port for a given protocol
 */
function defaultPortForProtocol(proto) {
    switch (proto) {
        case enums_1.ApplicationProtocol.Http: return 80;
        case enums_1.ApplicationProtocol.Https: return 443;
        default:
            throw new Error(`Unrecognized protocol: ${proto}`);
    }
}
exports.defaultPortForProtocol = defaultPortForProtocol;
/**
 * Return the appropriate default protocol for a given port
 */
function defaultProtocolForPort(port) {
    switch (port) {
        case 80:
        case 8000:
        case 8008:
        case 8080:
            return enums_1.ApplicationProtocol.Http;
        case 443:
        case 8443:
            return enums_1.ApplicationProtocol.Https;
        default:
            throw new Error(`Don't know default protocol for port: ${port}; please supply a protocol`);
    }
}
exports.defaultProtocolForPort = defaultProtocolForPort;
/**
 * Given a protocol and a port, try to guess the other one if it's undefined
 */
function determineProtocolAndPort(protocol, port) {
    if (protocol === undefined && port === undefined) {
        throw new Error('Supply at least one of protocol and port');
    }
    if (protocol === undefined) {
        protocol = defaultProtocolForPort(port);
    }
    if (port === undefined) {
        port = defaultPortForProtocol(protocol);
    }
    return [protocol, port];
}
exports.determineProtocolAndPort = determineProtocolAndPort;
/**
 * Helper function to default undefined input props
 */
function ifUndefined(x, def) {
    return x !== undefined ? x : def;
}
exports.ifUndefined = ifUndefined;
/**
 * Allow lazy evaluation of a list of dependables
 */
class LazyDependable {
    constructor(depList) {
        this.depList = depList;
    }
    get dependencyElements() {
        return this.depList;
    }
}
exports.LazyDependable = LazyDependable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSxtQ0FBOEM7QUFJOUM7O0dBRUc7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxVQUFzQjtJQUNyRCxNQUFNLEdBQUcsR0FBVSxFQUFFLENBQUM7SUFDdEIsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDckQsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUMxQjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBUkQsNENBUUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLEtBQTBCO0lBQy9ELFFBQVEsS0FBSyxFQUFFO1FBQ2IsS0FBSywyQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN6QyxLQUFLLDJCQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDO1FBQzNDO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUN0RDtBQUNILENBQUM7QUFQRCx3REFPQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isc0JBQXNCLENBQUMsSUFBWTtJQUNqRCxRQUFRLElBQUksRUFBRTtRQUNaLEtBQUssRUFBRSxDQUFDO1FBQ1IsS0FBSyxJQUFJLENBQUM7UUFDVixLQUFLLElBQUksQ0FBQztRQUNWLEtBQUssSUFBSTtZQUNQLE9BQU8sMkJBQW1CLENBQUMsSUFBSSxDQUFDO1FBRWxDLEtBQUssR0FBRyxDQUFDO1FBQ1QsS0FBSyxJQUFJO1lBQ1AsT0FBTywyQkFBbUIsQ0FBQyxLQUFLLENBQUM7UUFFbkM7WUFDRSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxJQUFJLDRCQUE0QixDQUFDLENBQUM7S0FDOUY7QUFDSCxDQUFDO0FBZkQsd0RBZUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLFFBQXlDLEVBQUUsSUFBd0I7SUFDMUcsSUFBSSxRQUFRLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7UUFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0tBQzdEO0lBRUQsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1FBQUUsUUFBUSxHQUFHLHNCQUFzQixDQUFDLElBQUssQ0FBQyxDQUFDO0tBQUU7SUFDekUsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1FBQUUsSUFBSSxHQUFHLHNCQUFzQixDQUFDLFFBQVMsQ0FBQyxDQUFDO0tBQUU7SUFFckUsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxQixDQUFDO0FBVEQsNERBU0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLFdBQVcsQ0FBSSxDQUFnQixFQUFFLEdBQU07SUFDckQsT0FBTyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNuQyxDQUFDO0FBRkQsa0NBRUM7QUFFRDs7R0FFRztBQUNILE1BQWEsY0FBYztJQUN6QixZQUE2QixPQUEwQjtRQUExQixZQUFPLEdBQVAsT0FBTyxDQUFtQjtJQUN2RCxDQUFDO0lBRUQsSUFBVyxrQkFBa0I7UUFDM0IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7Q0FDRjtBQVBELHdDQU9DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNkayA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2NkaycpO1xuaW1wb3J0IHsgQXBwbGljYXRpb25Qcm90b2NvbCB9IGZyb20gXCIuL2VudW1zXCI7XG5cbmV4cG9ydCB0eXBlIEF0dHJpYnV0ZXMgPSB7W2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkfTtcblxuLyoqXG4gKiBSZW5kZXIgYW4gYXR0cmlidXRlIGRpY3QgdG8gYSBsaXN0IG9mIHsga2V5LCB2YWx1ZSB9IHBhaXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgcmV0OiBhbnlbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXQucHVzaCh7IGtleSwgdmFsdWUgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBkZWZhdWx0IHBvcnQgZm9yIGEgZ2l2ZW4gcHJvdG9jb2xcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRQb3J0Rm9yUHJvdG9jb2wocHJvdG86IEFwcGxpY2F0aW9uUHJvdG9jb2wpOiBudW1iZXIge1xuICBzd2l0Y2ggKHByb3RvKSB7XG4gICAgY2FzZSBBcHBsaWNhdGlvblByb3RvY29sLkh0dHA6IHJldHVybiA4MDtcbiAgICBjYXNlIEFwcGxpY2F0aW9uUHJvdG9jb2wuSHR0cHM6IHJldHVybiA0NDM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHByb3RvY29sOiAke3Byb3RvfWApO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBkZWZhdWx0IHByb3RvY29sIGZvciBhIGdpdmVuIHBvcnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbEZvclBvcnQocG9ydDogbnVtYmVyKTogQXBwbGljYXRpb25Qcm90b2NvbCB7XG4gIHN3aXRjaCAocG9ydCkge1xuICAgIGNhc2UgODA6XG4gICAgY2FzZSA4MDAwOlxuICAgIGNhc2UgODAwODpcbiAgICBjYXNlIDgwODA6XG4gICAgICByZXR1cm4gQXBwbGljYXRpb25Qcm90b2NvbC5IdHRwO1xuXG4gICAgY2FzZSA0NDM6XG4gICAgY2FzZSA4NDQzOlxuICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uUHJvdG9jb2wuSHR0cHM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb24ndCBrbm93IGRlZmF1bHQgcHJvdG9jb2wgZm9yIHBvcnQ6ICR7cG9ydH07IHBsZWFzZSBzdXBwbHkgYSBwcm90b2NvbGApO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBwcm90b2NvbCBhbmQgYSBwb3J0LCB0cnkgdG8gZ3Vlc3MgdGhlIG90aGVyIG9uZSBpZiBpdCdzIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lUHJvdG9jb2xBbmRQb3J0KHByb3RvY29sOiBBcHBsaWNhdGlvblByb3RvY29sIHwgdW5kZWZpbmVkLCBwb3J0OiBudW1iZXIgfCB1bmRlZmluZWQpOiBbQXBwbGljYXRpb25Qcm90b2NvbCwgbnVtYmVyXSB7XG4gIGlmIChwcm90b2NvbCA9PT0gdW5kZWZpbmVkICYmIHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3VwcGx5IGF0IGxlYXN0IG9uZSBvZiBwcm90b2NvbCBhbmQgcG9ydCcpO1xuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSB1bmRlZmluZWQpIHsgcHJvdG9jb2wgPSBkZWZhdWx0UHJvdG9jb2xGb3JQb3J0KHBvcnQhKTsgfVxuICBpZiAocG9ydCA9PT0gdW5kZWZpbmVkKSB7IHBvcnQgPSBkZWZhdWx0UG9ydEZvclByb3RvY29sKHByb3RvY29sISk7IH1cblxuICByZXR1cm4gW3Byb3RvY29sLCBwb3J0XTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGVmYXVsdCB1bmRlZmluZWQgaW5wdXQgcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlmVW5kZWZpbmVkPFQ+KHg6IFQgfCB1bmRlZmluZWQsIGRlZjogVCkge1xuICByZXR1cm4geCAhPT0gdW5kZWZpbmVkID8geCA6IGRlZjtcbn1cblxuLyoqXG4gKiBBbGxvdyBsYXp5IGV2YWx1YXRpb24gb2YgYSBsaXN0IG9mIGRlcGVuZGFibGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5RGVwZW5kYWJsZSBpbXBsZW1lbnRzIGNkay5JRGVwZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGVwTGlzdDogY2RrLklEZXBlbmRhYmxlW10pIHtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVwZW5kZW5jeUVsZW1lbnRzKCk6IGNkay5JRGVwZW5kYWJsZVtdIHtcbiAgICByZXR1cm4gdGhpcy5kZXBMaXN0O1xuICB9XG59Il19