import cdk = require('@aws-cdk/cdk');
import { Condition } from '../condition';
import { StateGraph } from '../state-graph';
import { CatchProps, IChainable, INextable, RetryProps } from '../types';
/**
 * Properties shared by all states
 */
export interface StateProps {
    /**
     * A comment describing this state
     *
     * @default No comment
     */
    comment?: string;
    /**
     * JSONPath expression to select part of the state to be the input to this state.
     *
     * May also be the special value DISCARD, which will cause the effective
     * input to be the empty object {}.
     *
     * @default $
     */
    inputPath?: string;
    /**
     * JSONPath expression to select part of the state to be the output to this state.
     *
     * May also be the special value DISCARD, which will cause the effective
     * output to be the empty object {}.
     *
     * @default $
     */
    outputPath?: string;
    /**
     * JSONPath expression to indicate where to inject the state's output
     *
     * May also be the special value DISCARD, which will cause the state's
     * input to become its output.
     *
     * @default $
     */
    resultPath?: string;
}
/**
 * Base class for all other state classes
 */
export declare abstract class State extends cdk.Construct implements IChainable {
    /**
     * Add a prefix to the stateId of all States found in a construct tree
     */
    static prefixStates(root: cdk.Construct, prefix: string): void;
    /**
     * Find the set of end states states reachable through transitions from the given start state
     */
    static findReachableEndStates(start: State, options?: FindStateOptions): State[];
    /**
     * Return only the states that allow chaining from an array of states
     */
    static filterNextables(states: State[]): INextable[];
    /**
     * First state of this Chainable
     */
    readonly startState: State;
    /**
     * Continuable states of this Chainable
     */
    abstract readonly endStates: INextable[];
    protected readonly comment?: string;
    protected readonly inputPath?: string;
    protected readonly outputPath?: string;
    protected readonly resultPath?: string;
    protected readonly branches: StateGraph[];
    protected defaultChoice?: State;
    protected _next?: State;
    private readonly retries;
    private readonly catches;
    private readonly choices;
    private readonly prefixes;
    /**
     * The graph that this state is part of.
     *
     * Used for guaranteeing consistency between graphs and graph components.
     */
    private containingGraph?;
    /**
     * States with references to this state.
     *
     * Used for finding complete connected graph that a state is part of.
     */
    private readonly incomingStates;
    constructor(parent: cdk.Construct, id: string, props: StateProps);
    /**
     * Tokenized string that evaluates to the state's ID
     */
    readonly stateId: string;
    /**
     * Add a prefix to the stateId of this state
     */
    addPrefix(x: string): void;
    /**
     * Register this state as part of the given graph
     *
     * Don't call this. It will be called automatically when you work
     * states normally.
     */
    bindToGraph(graph: StateGraph): void;
    /**
     * Render the state as JSON
     */
    abstract toStateJson(): object;
    /**
     * Add a retrier to the retry list of this state
     */
    protected _addRetry(props?: RetryProps): void;
    /**
     * Add an error handler to the catch list of this state
     */
    protected _addCatch(handler: State, props?: CatchProps): void;
    /**
     * Make the indicated state the default transition of this state
     */
    protected makeNext(next: State): void;
    /**
     * Add a choice branch to this state
     */
    protected addChoice(condition: Condition, next: State): void;
    /**
     * Add a paralle branch to this state
     */
    protected addBranch(branch: StateGraph): void;
    /**
     * Make the indicated state the default choice transition of this state
     */
    protected makeDefault(def: State): void;
    /**
     * Render the default next state in ASL JSON format
     */
    protected renderNextEnd(): any;
    /**
     * Render the choices in ASL JSON format
     */
    protected renderChoices(): any;
    /**
     * Render InputPath/OutputPath in ASL JSON format
     */
    protected renderInputOutput(): any;
    /**
     * Render parallel branches in ASL JSON format
     */
    protected renderBranches(): any;
    /**
     * Render error recovery options in ASL JSON format
     */
    protected renderRetryCatch(): any;
    /**
     * Called whenever this state is bound to a graph
     *
     * Can be overridden by subclasses.
     */
    protected onBindToGraph(graph: StateGraph): void;
    /**
     * Add a state to the incoming list
     */
    private addIncoming;
    /**
     * Return all states this state can transition to
     */
    private outgoingTransitions;
}
/**
 * Options for finding reachable states
 */
export interface FindStateOptions {
    /**
     * Whether or not to follow error-handling transitions
     *
     * @default false
     */
    includeErrorHandlers?: boolean;
}
/**
 * Render a list or return undefined for an empty list
 */
export declare function renderList<T>(xs: T[], fn: (x: T) => any): any;
/**
 * Render JSON path, respecting the special value DISCARD
 */
export declare function renderJsonPath(jsonPath?: string): undefined | null | string;
/**
 * State types
 */
export declare enum StateType {
    Pass = "Pass",
    Task = "Task",
    Choice = "Choice",
    Wait = "Wait",
    Succeed = "Succeed",
    Fail = "Fail",
    Parallel = "Parallel"
}
