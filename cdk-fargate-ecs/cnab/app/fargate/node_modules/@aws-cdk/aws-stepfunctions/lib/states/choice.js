"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chain_1 = require("../chain");
const state_1 = require("./state");
/**
 * Define a Choice in the state machine
 *
 * A choice state can be used to make decisions based on the execution
 * state.
 */
class Choice extends state_1.State {
    constructor(parent, id, props = {}) {
        super(parent, id, props);
        this.endStates = [];
    }
    /**
     * If the given condition matches, continue execution with the given state
     */
    when(condition, next) {
        super.addChoice(condition, next.startState);
        return this;
    }
    /**
     * If none of the given conditions match, continue execution with the given state
     *
     * If no conditions match and no otherwise() has been given, an execution
     * error will be raised.
     */
    otherwise(def) {
        super.makeDefault(def.startState);
        return this;
    }
    /**
     * Return a Chain that contains all reachable end states from this Choice
     *
     * Use this to combine all possible choice paths back.
     */
    afterwards(options = {}) {
        const endStates = state_1.State.filterNextables(state_1.State.findReachableEndStates(this, { includeErrorHandlers: options.includeErrorHandlers }));
        if (options.includeOtherwise && this.defaultChoice) {
            throw new Error(`'includeOtherwise' set but Choice state ${this.stateId} already has an 'otherwise' transition`);
        }
        if (options.includeOtherwise) {
            endStates.push(new DefaultAsNext(this));
        }
        return chain_1.Chain.custom(this, endStates, this);
    }
    /**
     * Return the Amazon States Language object for this state
     */
    toStateJson() {
        return Object.assign({ Type: state_1.StateType.Choice, Comment: this.comment }, this.renderInputOutput(), this.renderChoices());
    }
}
exports.Choice = Choice;
/**
 * Adapter to make the .otherwise() transition settable through .next()
 */
class DefaultAsNext {
    constructor(choice) {
        this.choice = choice;
    }
    next(state) {
        this.choice.otherwise(state);
        return chain_1.Chain.sequence(this.choice, state);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hvaWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2hvaWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0Esb0NBQWlDO0FBR2pDLG1DQUEyQztBQWtDM0M7Ozs7O0dBS0c7QUFDSCxNQUFhLE1BQU8sU0FBUSxhQUFLO0lBRzdCLFlBQVksTUFBcUIsRUFBRSxFQUFVLEVBQUUsUUFBcUIsRUFBRTtRQUNsRSxLQUFLLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUhiLGNBQVMsR0FBZ0IsRUFBRSxDQUFDO0lBSTVDLENBQUM7SUFFRDs7T0FFRztJQUNJLElBQUksQ0FBQyxTQUFvQixFQUFFLElBQWdCO1FBQzlDLEtBQUssQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM1QyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxTQUFTLENBQUMsR0FBZTtRQUM1QixLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFVBQVUsQ0FBQyxVQUE2QixFQUFFO1FBQzdDLE1BQU0sU0FBUyxHQUFHLGFBQUssQ0FBQyxlQUFlLENBQUMsYUFBSyxDQUFDLHNCQUFzQixDQUFDLElBQUksRUFBRSxFQUFFLG9CQUFvQixFQUFFLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwSSxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksQ0FBQyxPQUFPLHdDQUF3QyxDQUFDLENBQUM7U0FDcEg7UUFDRCxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRTtZQUMxQixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLGFBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXO1FBQ2QsdUJBQ0ksSUFBSSxFQUFFLGlCQUFTLENBQUMsTUFBTSxFQUN0QixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sSUFDbEIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQ3hCLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFDekI7SUFDTixDQUFDO0NBQ0o7QUFyREQsd0JBcURDO0FBMkJEOztHQUVHO0FBQ0gsTUFBTSxhQUFhO0lBQ2YsWUFBNkIsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7SUFDM0MsQ0FBQztJQUVNLElBQUksQ0FBQyxLQUFpQjtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixPQUFPLGFBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5QyxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2RrID0gcmVxdWlyZSgnQGF3cy1jZGsvY2RrJyk7XG5pbXBvcnQgeyBDaGFpbiB9IGZyb20gJy4uL2NoYWluJztcbmltcG9ydCB7IENvbmRpdGlvbiB9IGZyb20gJy4uL2NvbmRpdGlvbic7XG5pbXBvcnQgeyBJQ2hhaW5hYmxlLCBJTmV4dGFibGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTdGF0ZSwgU3RhdGVUeXBlIH0gZnJvbSAnLi9zdGF0ZSc7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgZGVmaW5pbmcgYSBDaG9pY2Ugc3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaG9pY2VQcm9wcyB7XG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgZGVzY3JpcHRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IE5vIGNvbW1lbnRcbiAgICAgKi9cbiAgICBjb21tZW50Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSlNPTlBhdGggZXhwcmVzc2lvbiB0byBzZWxlY3QgcGFydCBvZiB0aGUgc3RhdGUgdG8gYmUgdGhlIGlucHV0IHRvIHRoaXMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBNYXkgYWxzbyBiZSB0aGUgc3BlY2lhbCB2YWx1ZSBESVNDQVJELCB3aGljaCB3aWxsIGNhdXNlIHRoZSBlZmZlY3RpdmVcbiAgICAgKiBpbnB1dCB0byBiZSB0aGUgZW1wdHkgb2JqZWN0IHt9LlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJFxuICAgICAqL1xuICAgIGlucHV0UGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEpTT05QYXRoIGV4cHJlc3Npb24gdG8gc2VsZWN0IHBhcnQgb2YgdGhlIHN0YXRlIHRvIGJlIHRoZSBvdXRwdXQgdG8gdGhpcyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIE1heSBhbHNvIGJlIHRoZSBzcGVjaWFsIHZhbHVlIERJU0NBUkQsIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGVmZmVjdGl2ZVxuICAgICAqIG91dHB1dCB0byBiZSB0aGUgZW1wdHkgb2JqZWN0IHt9LlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJFxuICAgICAqL1xuICAgIG91dHB1dFBhdGg/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgQ2hvaWNlIGluIHRoZSBzdGF0ZSBtYWNoaW5lXG4gKlxuICogQSBjaG9pY2Ugc3RhdGUgY2FuIGJlIHVzZWQgdG8gbWFrZSBkZWNpc2lvbnMgYmFzZWQgb24gdGhlIGV4ZWN1dGlvblxuICogc3RhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaG9pY2UgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgcHVibGljIHJlYWRvbmx5IGVuZFN0YXRlczogSU5leHRhYmxlW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogY2RrLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IENob2ljZVByb3BzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBpZCwgcHJvcHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBnaXZlbiBjb25kaXRpb24gbWF0Y2hlcywgY29udGludWUgZXhlY3V0aW9uIHdpdGggdGhlIGdpdmVuIHN0YXRlXG4gICAgICovXG4gICAgcHVibGljIHdoZW4oY29uZGl0aW9uOiBDb25kaXRpb24sIG5leHQ6IElDaGFpbmFibGUpOiBDaG9pY2Uge1xuICAgICAgICBzdXBlci5hZGRDaG9pY2UoY29uZGl0aW9uLCBuZXh0LnN0YXJ0U3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBub25lIG9mIHRoZSBnaXZlbiBjb25kaXRpb25zIG1hdGNoLCBjb250aW51ZSBleGVjdXRpb24gd2l0aCB0aGUgZ2l2ZW4gc3RhdGVcbiAgICAgKlxuICAgICAqIElmIG5vIGNvbmRpdGlvbnMgbWF0Y2ggYW5kIG5vIG90aGVyd2lzZSgpIGhhcyBiZWVuIGdpdmVuLCBhbiBleGVjdXRpb25cbiAgICAgKiBlcnJvciB3aWxsIGJlIHJhaXNlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3RoZXJ3aXNlKGRlZjogSUNoYWluYWJsZSk6IENob2ljZSB7XG4gICAgICAgIHN1cGVyLm1ha2VEZWZhdWx0KGRlZi5zdGFydFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgQ2hhaW4gdGhhdCBjb250YWlucyBhbGwgcmVhY2hhYmxlIGVuZCBzdGF0ZXMgZnJvbSB0aGlzIENob2ljZVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgdG8gY29tYmluZSBhbGwgcG9zc2libGUgY2hvaWNlIHBhdGhzIGJhY2suXG4gICAgICovXG4gICAgcHVibGljIGFmdGVyd2FyZHMob3B0aW9uczogQWZ0ZXJ3YXJkc09wdGlvbnMgPSB7fSk6IENoYWluIHtcbiAgICAgICAgY29uc3QgZW5kU3RhdGVzID0gU3RhdGUuZmlsdGVyTmV4dGFibGVzKFN0YXRlLmZpbmRSZWFjaGFibGVFbmRTdGF0ZXModGhpcywgeyBpbmNsdWRlRXJyb3JIYW5kbGVyczogb3B0aW9ucy5pbmNsdWRlRXJyb3JIYW5kbGVycyB9KSk7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVPdGhlcndpc2UgJiYgdGhpcy5kZWZhdWx0Q2hvaWNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCdpbmNsdWRlT3RoZXJ3aXNlJyBzZXQgYnV0IENob2ljZSBzdGF0ZSAke3RoaXMuc3RhdGVJZH0gYWxyZWFkeSBoYXMgYW4gJ290aGVyd2lzZScgdHJhbnNpdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVPdGhlcndpc2UpIHtcbiAgICAgICAgICAgIGVuZFN0YXRlcy5wdXNoKG5ldyBEZWZhdWx0QXNOZXh0KHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhaW4uY3VzdG9tKHRoaXMsIGVuZFN0YXRlcywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBBbWF6b24gU3RhdGVzIExhbmd1YWdlIG9iamVjdCBmb3IgdGhpcyBzdGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0YXRlSnNvbigpOiBvYmplY3Qge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVHlwZTogU3RhdGVUeXBlLkNob2ljZSxcbiAgICAgICAgICAgIENvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgICAgIC4uLnRoaXMucmVuZGVySW5wdXRPdXRwdXQoKSxcbiAgICAgICAgICAgIC4uLnRoaXMucmVuZGVyQ2hvaWNlcygpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzZWxlY3RpbmcgdGhlIGNob2ljZSBwYXRoc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFmdGVyd2FyZHNPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGluY2x1ZGUgZXJyb3IgaGFuZGxpbmcgc3RhdGVzXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHRydWUsIGFsbCBzdGF0ZXMgd2hpY2ggYXJlIGVycm9yIGhhbmRsZXJzIChhZGRlZCB0aHJvdWdoICdvbkVycm9yJylcbiAgICAgKiBhbmQgc3RhdGVzIHJlYWNoYWJsZSB2aWEgZXJyb3IgaGFuZGxlcnMgd2lsbCBiZSBpbmNsdWRlZCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBpbmNsdWRlRXJyb3JIYW5kbGVycz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGRlZmF1bHQvb3RoZXJ3aXNlIHRyYW5zaXRpb24gZm9yIHRoZSBjdXJyZW50IENob2ljZSBzdGF0ZVxuICAgICAqXG4gICAgICogSWYgdGhpcyBpcyB0cnVlIGFuZCB0aGUgY3VycmVudCBDaG9pY2UgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb3V0Z29pbmdcbiAgICAgKiB0cmFuc2l0aW9uLCBvbmUgd2lsbCBiZSBhZGRlZCBpbmNsdWRlZCB3aGVuIC5uZXh0KCkgaXMgY2FsbGVkIG9uIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaW5jbHVkZU90aGVyd2lzZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQWRhcHRlciB0byBtYWtlIHRoZSAub3RoZXJ3aXNlKCkgdHJhbnNpdGlvbiBzZXR0YWJsZSB0aHJvdWdoIC5uZXh0KClcbiAqL1xuY2xhc3MgRGVmYXVsdEFzTmV4dCBpbXBsZW1lbnRzIElOZXh0YWJsZSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjaG9pY2U6IENob2ljZSkge1xuICAgIH1cblxuICAgIHB1YmxpYyBuZXh0KHN0YXRlOiBJQ2hhaW5hYmxlKTogQ2hhaW4ge1xuICAgICAgICB0aGlzLmNob2ljZS5vdGhlcndpc2Uoc3RhdGUpO1xuICAgICAgICByZXR1cm4gQ2hhaW4uc2VxdWVuY2UodGhpcy5jaG9pY2UsIHN0YXRlKTtcbiAgICB9XG59Il19